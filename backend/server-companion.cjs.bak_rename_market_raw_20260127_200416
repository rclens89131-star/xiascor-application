/**
 * Companion Sorare — backend propre
 * - /health
 * - /public-user-cards-page?identifier=darkflow&first=20&after=...&enrich=1
 * - /public-player?slug=...
 * - /scout/cards?first=20&eurOnly=1&q=mbappe&rarities=limited,rare&maxEur=50&sort=eur_asc
 * - /scout/watchlist (GET/POST/DELETE)
 * - /scout/alerts (GET/POST/DELETE)
 *
 * Node >= 18 (fetch dispo). Recommandé: Node 20.
 */

const express = require("express");
const cors = require("cors");



require("dotenv").config();
const app = express();
app.use(cors());
app.use(express.json());

// ----------------------------
// Config
// ----------------------------
const PORT = Number(process.env.PORT || 3000);
const HOST = process.env.HOST || "0.0.0.0";

// IMPORTANT: endpoint GraphQL (on force federation)
const SORARE_GQL = "https://api.sorare.com/graphql";


const SORARE_APIKEY = process.env.SORARE_APIKEY || process.env.SORARE_API_KEY || "";
const SORARE_JWT    = process.env.SORARE_JWT || "";

const SORARE_JWT_AUD = process.env.SORARE_JWT_AUD || "";
const HAS_SORARE_KEY = Boolean(SORARE_APIKEY || SORARE_JWT);

function sorareHeaders() {
  const h = { "content-type": "application/json" }
const SORARE_OAUTH_UID = process.env.SORARE_OAUTH_UID || "";
const SORARE_OAUTH_SECRET = process.env.SORARE_OAUTH_SECRET || "";
const SORARE_OAUTH_REDIRECT_URI = process.env.SORARE_OAUTH_REDIRECT_URI || "http://localhost:3000/auth/sorare/callback";
const OAUTH_TOKEN_FILE = dataFile("sorare_oauth.json");

function readOAuthToken() {
  return readJson(OAUTH_TOKEN_FILE, null);
}

function hasSorareAuth() {
  const t = readOAuthToken();
  return Boolean(SORARE_APIKEY || SORARE_JWT || (t && t.access_token));
}
;
  if (SORARE_JWT) h["authorization"] = "Bearer " + SORARE_JWT;
  
  if (SORARE_JWT_AUD) h["JWT-AUD"] = SORARE_JWT_AUD;
if (SORARE_APIKEY) {
    // Sorare docs: header APIKEY
    h["APIKEY"] = SORARE_APIKEY;
  }
    // OAuth access token fallback (si pas d'APIKEY/JWT)
  if (!h["authorization"] && !SORARE_APIKEY) {
    const t = readOAuthToken();
    if (t && t.access_token) h["authorization"] = "Bearer " + t.access_token;
  }
  // OAuth access token fallback (si pas d'APIKEY/JWT)
  if (!h["authorization"] && !SORARE_APIKEY) {
    const t = readOAuthToken();
    if (t && t.access_token) h["authorization"] = "Bearer " + t.access_token;
  }

  return h;
}
// ----------------------------
// Utils: Disk JSON
// ----------------------------
function dataFile(name) {
  const path = require("path");
  return path.join(__dirname, "data", name);
}

function readJson(file, fallback) {
  try {
    const fs = require("fs");
    if (!fs.existsSync(file)) return fallback;
    const raw = fs.readFileSync(file, "utf8");
    if (!raw) return fallback;
    return JSON.parse(raw);
  } catch {
    return fallback;
  }
}

function writeJson(file, obj) {
  try {
    const fs = require("fs");
    const path = require("path");
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(file, JSON.stringify(obj, null, 2), "utf8");
  } catch {}
}

// ----------------------------
// Disk cache (scout)
// ----------------------------
function scoutCacheFile() {
  return dataFile("scout_cache.json");
}

function scoutCacheRead() {
  const j = readJson(scoutCacheFile(), {});
  // support old formats too:
  // { last: {key, items, ts}, byKey: {key: payload} }
  // OR { key, items, cachedAt } (ancien)
  if (j && typeof j === "object") {
    if (j.byKey || j.last) {
      return { last: j.last || null, byKey: j.byKey || {} };
    }
    if (j.key && Array.isArray(j.items)) {
      const payload = { key: j.key, items: j.items, ts: Date.now() };
      return { last: payload, byKey: { [j.key]: payload } };
    }
  }
  return { last: null, byKey: {} };
}

function scoutCacheWrite(c) {
  writeJson(scoutCacheFile(), c);
}

function scoutCacheGet(key) {
  const c = scoutCacheRead();
  if (c.byKey && c.byKey[key]) return c.byKey[key];
  return c.last || null;
}

function scoutCacheSet(key, payload) {
  const c = scoutCacheRead();
  c.byKey = c.byKey || {};
  c.byKey[key] = payload;
  c.last = payload;
  scoutCacheWrite(c);
}

// ----------------------------
// Sorare GraphQL helper
// ----------------------------
async function sorareGraphQL(query, variables) {
  const res = await fetch(SORARE_GQL, {
    method: "POST",
    headers: sorareHeaders(),
    body: JSON.stringify({ query, variables: variables || {} }),
  });

  // ex: 429, 502...
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    const err = new Error(`Sorare HTTP ${res.status}`);
    err.status = res.status;
    err.body = txt;
    throw err;
  }

  const json = await res.json();
  if (json.errors && json.errors.length) {
    const err = new Error(json.errors[0]?.message || "Sorare GraphQL error");
    err.graphQLErrors = json.errors;
    err.data = json.data;
    throw err;
  }
  return json.data;
}

// ----------------------------
// Identifier -> slug (user)
// ----------------------------
function resolveUserSlug(identifier) {
  const s = String(identifier || "").trim();
  if (!s) return "";

  // URL sorare club
  // ex: https://sorare.com/fr/football/my-club/darkflow
  // ex: https://sorare.com/fr/football/clubs/darkflow
  const m1 = s.match(/sorare\.com\/[^\/]+\/football\/my-club\/([^\/\?#]+)/i);
  if (m1) return m1[1];
  const m2 = s.match(/sorare\.com\/[^\/]+\/football\/clubs\/([^\/\?#]+)/i);
  if (m2) return m2[1];

  // sinon on suppose slug direct
  return s.replace(/^@/, "");
}

// ----------------------------
// anyCards enrichment (robuste avec fallbacks)
// ----------------------------
async function fetchAnyCards(slugs) {
  const uniq = Array.from(new Set((slugs || []).filter(Boolean)));
  if (!uniq.length) return [];

  const queries = [
    // "riche" (peut échouer si certains champs n'existent pas)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          serialNumber
          anyPositions
          pictureUrl
          anyTeam { name slug }
          anyPlayer { displayName slug }
        }
      }
    `,
    // fallback 1 (retire slug player/team si ça casse)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          serialNumber
          anyPositions
          pictureUrl
          anyTeam { name }
          anyPlayer { displayName }
        }
      }
    `,
    // fallback 2 (minimal)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          anyPositions
        }
      }
    `,
  ];

  let lastErr = null;
  for (const q of queries) {
    try {
      const data = await sorareGraphQL(q, { slugs: uniq });
      return (data && data.anyCards) ? data.anyCards : [];
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error("anyCards failed");
}

// ----------------------------
// Live single sale offers (public) + EUR best-effort
// ----------------------------
async function fetchLiveSingleSaleOffers(lastN) {
  const N = Math.max(1, Math.min(Number(lastN || 50), 200));

  // Sans clé: on réduit la complexité (pas de pictureUrl)
  const qEur_PUBLIC = `
    query Live($last:Int!) {
      tokens {
        liveSingleSaleOffers(last:$last) {
          nodes {
            id
            senderSide {
              anyCards { slug }
              amounts { eurCents }
            }
          }
        }
      }
    }
  `;

  const qEur_REAL = `
    query Live($last:Int!) {
      tokens {
        liveSingleSaleOffers(last:$last) {
          nodes {
            id
            senderSide {
              anyCards { slug pictureUrl }
              amounts { eurCents }
            }
          }
        }
      }
    }
  `;

  const qWei_PUBLIC = `
    query Live($last:Int!) {
      tokens {
        liveSingleSaleOffers(last:$last) {
          nodes {
            id
            senderSide {
              anyCards { slug }
              amounts { wei }
            }
          }
        }
      }
    }
  `;

  const qWei_REAL = `
    query Live($last:Int!) {
      tokens {
        liveSingleSaleOffers(last:$last) {
          nodes {
            id
            senderSide {
              anyCards { slug pictureUrl }
              amounts { wei }
            }
          }
        }
      }
    }
  `;

  const qEur = hasSorareAuth() ? qEur_REAL : qEur_PUBLIC;
  const qWei = HAS ? qWei_REAL : qWei_PUBLIC;

  try {
    const data = await sorareGraphQL(qEur, { last: N });
    const nodes = data?.tokens?.liveSingleSaleOffers?.nodes || [];
    return { nodes, eurMode: "eurCents" };
  } catch (e) {
    const data2 = await sorareGraphQL(qWei, { last: N });
    const nodes2 = data2?.tokens?.liveSingleSaleOffers?.nodes || [];
    return { nodes: nodes2, eurMode: "weiOnly" };
  }
}

// ----------------------------
// Routes
// ----------------------------
app.get("/health", (req, res) => res.json({ ok: true }));

// Public user cards (paged)
app.get("/public-user-cards-page", async (req, res) => {
  try {
    const identifier = String(req.query.identifier || "").trim();
    const HAS = hasSorareAuth();
  const first = Math.max(1, Math.min(Number(req.query.first || 20), HAS ? 50 : 10));
    const after = req.query.after ? String(req.query.after) : null;
    const enrich = String(req.query.enrich || "0") === "1";

    const slug = resolveUserSlug(identifier);
    if (!slug) return res.status(400).json({ error: "identifier missing" });

    // Query minimal (robuste)
    const q1 = `
      query UserCards($slug:String!, $first:Int!, $after:String) {
        user(slug:$slug) {
          slug
          nickname
          cards(first:$first, after:$after) {
            nodes { slug pictureUrl }
            pageInfo { endCursor hasNextPage }
          }
        }
      }
    `;

    let userData;
    try {
      userData = await sorareGraphQL(q1, { slug, first, after });
    } catch (e) {
      // fallback sans pictureUrl si ça casse
      const q2 = `
        query UserCards($slug:String!, $first:Int!, $after:String) {
          user(slug:$slug) {
            slug
            nickname
            cards(first:$first, after:$after) {
              nodes { slug }
              pageInfo { endCursor hasNextPage }
            }
          }
        }
      `;
      userData = await sorareGraphQL(q2, { slug, first, after });
    }

    const u = userData?.user;
    if (!u) return res.status(404).json({ error: "user not found or not public" });

    let cards = (u.cards?.nodes || []).map(c => ({
      slug: c.slug,
      pictureUrl: c.pictureUrl || null,
    }));

    // Enrich via anyCards(slugs)
    if (enrich && cards.length) {
      const slugs = cards.map(c => c.slug).filter(Boolean);
      const enriched = await fetchAnyCards(slugs);
      const map = new Map(enriched.map(x => [x.slug, x]));

      cards = cards.map(c => {
        const e = map.get(c.slug);
        if (!e) return c;
        return {
          ...c,
          pictureUrl: c.pictureUrl || e.pictureUrl || null,
          rarity: e.rarityTyped || null,
          seasonYear: e.seasonYear || null,
          serialNumber: (typeof e.serialNumber === "number") ? e.serialNumber : null,
          position: Array.isArray(e.anyPositions) ? (e.anyPositions[0] || null) : null,
          positions: Array.isArray(e.anyPositions) ? e.anyPositions : [],
          team: e.anyTeam?.name || null,
          teamSlug: e.anyTeam?.slug || null,
          playerName: e.anyPlayer?.displayName || null,
          playerSlug: e.anyPlayer?.slug || null,
        };
      });
    }

    res.json({
      slug: u.slug,
      nickname: u.nickname || null,
      cards,
      pageInfo: u.cards?.pageInfo || { endCursor: null, hasNextPage: false },
    });
  } catch (e) {
    res.status(500).json({
      error: String(e.message || e),
      status: e.status || null,
      graphQLErrors: e.graphQLErrors || null,
    });
  }
});

// Public player info (best-effort, plusieurs shapes)
  // XS_PUBLIC_PLAYER_SAFE (schema-safe)
  app.get("/public-player", async (req, res) => {
    try {
      const slug = String(req.query.slug || "").trim();
      if (!slug) return res.status(400).json({ error: "slug missing" });

      const url = "https://api.sorare.com/graphql";
      const query = `
        query PublicPlayer($slug: String!) {
          football {
            player(slug: $slug) {
              slug
              displayName
              anyPositions
              activeClub { name slug }
            }
          }
        }
      `;
      const variables = { slug };

      const r = await fetch(url, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "accept": "application/json",
        },
        body: JSON.stringify({ query, variables }),
      });

      const text = await r.text();

      if (!r.ok) {
        return res.status(502).json({
          error: "public-player query failed (upstream).",
          details: "Sorare HTTP " + r.status,
          body: text.slice(0, 3000),
        });
      }

      let json;
      try { json = JSON.parse(text); }
      catch {
        return res.status(502).json({
          error: "public-player query failed (non-JSON).",
          details: "Sorare returned non-JSON",
          body: text.slice(0, 3000),
        });
      }

      if (json.errors) {
        return res.status(502).json({
          error: "public-player query failed (graphql errors).",
          details: "Sorare GraphQL errors",
          graphQLErrors: json.errors,
        });
      }

      const p = json && json.data && json.data.football ? json.data.football.player : null;
      if (!p) return res.status(404).json({ error: "player not found", slug });

      const position =
        Array.isArray(p.anyPositions) && p.anyPositions[0]
          ? (typeof p.anyPositions[0] === "string" ? p.anyPositions[0] : (p.anyPositions[0] && p.anyPositions[0].position))
          : null;

      return res.json({
        playerSlug: p.slug,
        playerName: p.displayName || p.slug,
        position,
        activeClub: p.activeClub ? { name: p.activeClub.name, slug: p.activeClub.slug } : null,
      });

    } catch (e) {
      console.error("[public-player] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String((e && e.message) ? e.message : e) });
    }
  });
app.get("/public-player-old", async (req, res) => {
  const slug = String(req.query.slug || "").trim();
  if (!slug) return res.status(400).json({ error: "slug missing" });

  const tries = [
    // shape 1
    `
      query P($slug:String!) {
        football {
          player(slug:$slug) {
            slug
            displayName
            anyPositions
            activeClub { name slug }
          }
        }
      }
    `,
    // shape 2
    `
      query P($slug:String!) {
        footballPlayer(slug:$slug) {
          slug
          displayName
          anyPositions
          activeClub { name slug }
        }
      }
    `,
    // shape 3
    `
      query P($slug:String!) {
        player(slug:$slug) {
          ... on FootballPlayer {
            slug
            displayName
            anyPositions
            activeClub { name slug }
          }
        }
      }
    `,
  ];

  let lastErr = null;
  for (const q of tries) {
    try {
      const data = await sorareGraphQL(q, { slug });
      const p =
        data?.football?.player ||
        data?.footballPlayer ||
        data?.player ||
        null;

      if (!p) continue;

      return res.json({
        slug: p.slug || slug,
        displayName: p.displayName || null,
        positions: Array.isArray(p.anyPositions) ? p.anyPositions : [],
        position: Array.isArray(p.anyPositions) ? (p.anyPositions[0] || null) : null,
        activeClub: p.activeClub ? { name: p.activeClub.name || null, slug: p.activeClub.slug || null } : null,
      });
    } catch (e) {
      lastErr = e;
    }
  }

  return res.status(500).json({
    error: "public-player query failed (schema mismatch).",
    details: String(lastErr?.message || lastErr || ""),
    graphQLErrors: lastErr?.graphQLErrors || null,
  });
});

// Scout — cards (public market snapshot + cache)
app.get("/scout/cards", async (req, res) => {
  const HAS = hasSorareAuth();
  const first = Math.max(1, Math.min(Number(req.query.first || 20), HAS ? 50 : 10));
  const eurOnly = String(req.query.eurOnly || "0") === "1";
  const maxEur = req.query.maxEur ? Number(req.query.maxEur) : null;
  const qRaw = String(req.query.q || "").trim().toLowerCase();
  const raritiesRaw = String(req.query.rarities || "").trim().toLowerCase(); // "limited,rare"
  const sort = String(req.query.sort || "").trim().toLowerCase(); // eur_asc|eur_desc|newest

  const rarities = raritiesRaw
    ? raritiesRaw.split(",").map(s => s.trim()).filter(Boolean)
    : [];

  const cacheKey = ["scout", qRaw, rarities.join(","), eurOnly ? "eur" : "any", (Number.isFinite(maxEur) ? maxEur : ""), sort].join("|");
  const cached = scoutCacheGet(cacheKey);
  let fromCache = false;
  let cacheExact = false;

  try {
    // On tire plus large, puis on filtre localement (public API limitée)
    const lastN = HAS ? Math.min(200, Math.max(50, first * 5)) : 10; // sans auth: public-safe
    const { nodes, eurMode } = await fetchLiveSingleSaleOffers(lastN);

    // Flatten offers -> card slugs
    const offers = [];
    const slugs = [];
    for (const o of (nodes || [])) {
      const c = o?.senderSide?.anyCards?.[0];
      if (!c?.slug) continue;

      let eur = null;
      const amt = o?.senderSide?.amounts || null;
      if (amt) {
        if (typeof amt.eurCents === "number") eur = amt.eurCents / 100;
      }

      offers.push({
        offerId: o.id,
        slug: c.slug,
        pictureUrl: c.pictureUrl || null,
        eur,
        eurMode,
      });
      slugs.push(c.slug);
    }

    // Enrich cards (player/team/positions/rarity/seasonYear)
    let enriched = [];
    try {
      enriched = await fetchAnyCards(slugs);
    } catch {
      enriched = [];
    }
    const map = new Map(enriched.map(x => [x.slug, x]));

    let items = offers.map(o => {
      const e = map.get(o.slug);
      const rarity = e?.rarityTyped || null;

      return {
        offerId: o.offerId,
        slug: o.slug,
        pictureUrl: o.pictureUrl || e?.pictureUrl || null,
        rarity,
        seasonYear: e?.seasonYear || null,
        serialNumber: (typeof e?.serialNumber === "number") ? e.serialNumber : null,
        positions: Array.isArray(e?.anyPositions) ? e.anyPositions : [],
        position: Array.isArray(e?.anyPositions) ? (e.anyPositions[0] || null) : null,
        team: e?.anyTeam?.name || null,
        teamSlug: e?.anyTeam?.slug || null,
        playerName: e?.anyPlayer?.displayName || null,
        playerSlug: e?.anyPlayer?.slug || null,
      eur: (() => { const c = n?.receiverSide?.amounts?.eurCents; if (c === null || c === undefined) return null; const num = (typeof c === "number") ? c : parseInt(String(c), 10); if (!Number.isFinite(num)) return null; return num / 100; })(),
      };
    });

    // Filters
    if (rarities.length) {
      items = items.filter(x => x.rarity && rarities.includes(String(x.rarity).toLowerCase()));
    }
    if (qRaw) {
      items = items.filter(x => {
        const pn = String(x.playerName || "").toLowerCase();
        const ps = String(x.playerSlug || "").toLowerCase();
        const ts = String(x.team || "").toLowerCase();
        return pn.includes(qRaw) || ps.includes(qRaw) || ts.includes(qRaw);
      });
    }
    if (eurOnly) {
      items = items.filter(x => typeof x.eur === "number" && Number.isFinite(x.eur));
    }
    if (Number.isFinite(maxEur)) {
      items = items.filter(x => (typeof x.eur === "number" && x.eur <= maxEur));
    }

    // Sort
    if (sort === "eur_asc") {
      items.sort((a,b) => (a.eur ?? Infinity) - (b.eur ?? Infinity));
    } else if (sort === "eur_desc") {
      items.sort((a,b) => (b.eur ?? -Infinity) - (a.eur ?? -Infinity));
    } // else "newest": keep order

    // Trim to first
    items = items.slice(0, first);

    // Cache fallback if empty
    if ((!items || items.length === 0) && cached && Array.isArray(cached.items) && cached.items.length) {
      items = cached.items;
      fromCache = true;
      cacheExact = !!(cached.key && cached.key === cacheKey);
    }

    // Save cache if non-empty and not from cache
    if (!fromCache && Array.isArray(items) && items.length) {
      scoutCacheSet(cacheKey, { key: cacheKey, items, ts: Date.now() });
    }

    res.json({
      key: cacheKey,
      fromCache,
      cacheExact,
      count: items.length,
      items,
      note: "V1: liveSingleSaleOffers (public). Limite PUBLIC: first cap à 10 + last=10 pour rester sous complexity=500. Attention: rate-limit possible; filtres appliqués localement.",
    });
  } catch (e) {
    // On tente cache en dernier recours
    if (cached && Array.isArray(cached.items) && cached.items.length) {
      fromCache = true;
      cacheExact = !!(cached.key && cached.key === cacheKey);
      return res.json({
        key: cacheKey,
        fromCache,
        cacheExact,
        count: cached.items.length,
        items: cached.items,
        note: "Fallback cache (erreur API publique).",
        apiError: String(e.message || e),
        apiStatus: e.status || null,
      });
    }

    res.status(500).json({
      error: String(e.message || e),
      status: e.status || null,
      graphQLErrors: e.graphQLErrors || null,
    });
  }
});

// ----------------------------
// Watchlist / Alerts (simple JSON CRUD)
// ----------------------------
const WATCHLIST_FILE = dataFile("scout_watchlist.json");
const ALERTS_FILE = dataFile("scout_alerts.json");

app.get("/scout/watchlist", (req, res) => {
  const list = readJson(WATCHLIST_FILE, []);
  res.json({ items: Array.isArray(list) ? list : [] });
});

app.post("/scout/watchlist", (req, res) => {
  const list = readJson(WATCHLIST_FILE, []);
  const item = req.body || {};
  const id = item.id || ("w_" + Date.now() + "_" + Math.random().toString(16).slice(2));
  const next = Array.isArray(list) ? list : [];
  next.push({ ...item, id });
  writeJson(WATCHLIST_FILE, next);
  res.json({ ok: true, id });
});

app.delete("/scout/watchlist/:id", (req, res) => {
  const id = String(req.params.id || "");
  const list = readJson(WATCHLIST_FILE, []);
  const next = (Array.isArray(list) ? list : []).filter(x => String(x.id) !== id);
  writeJson(WATCHLIST_FILE, next);
  res.json({ ok: true });
});

app.get("/scout/alerts", (req, res) => {
  const list = readJson(ALERTS_FILE, []);
  res.json({ items: Array.isArray(list) ? list : [] });
});

app.post("/scout/alerts", (req, res) => {
  const list = readJson(ALERTS_FILE, []);
  const item = req.body || {};
  const id = item.id || ("a_" + Date.now() + "_" + Math.random().toString(16).slice(2));
  const next = Array.isArray(list) ? list : [];
  next.push({ ...item, id });
  writeJson(ALERTS_FILE, next);
  res.json({ ok: true, id });
});

app.delete("/scout/alerts/:id", (req, res) => {
  const id = String(req.params.id || "");
  const list = readJson(ALERTS_FILE, []);
  const next = (Array.isArray(list) ? list : []).filter(x => String(x.id) !== id);
  writeJson(ALERTS_FILE, next);
  res.json({ ok: true });
});

// ----------------------------
/* ===== OAuth Sorare ===== */
function _fetchAny(...args) {
  if (typeof fetch === "function") return fetch(...args);
  // Node < 18 fallback (optionnel)
  return import("node-fetch").then(m => m.default(...args));
}

app.get("/auth/sorare", (req, res) => {
  if (!SORARE_OAUTH_UID || !SORARE_OAUTH_SECRET) {
    return res.status(400).json({ error: "OAuth non configuré: SORARE_OAUTH_UID/SECRET manquants" });
  }
  const u = encodeURIComponent(SORARE_OAUTH_UID);
  const r = encodeURIComponent(SORARE_OAUTH_REDIRECT_URI);
  const url = `https://sorare.com/oauth/authorize?client_id=${u}&redirect_uri=${r}&response_type=code&scope=public`;
  res.redirect(url);
});

app.get("/auth/sorare/callback", async (req, res) => {
  
    // ===== XS_DEVICE_OAUTH_BRIDGE_V1 =====
    // Si ce callback reçoit un state généré par /auth/sorare-device/login,
    // on stocke un token PAR deviceId dans oauth_devices.json, puis on return.
    try {
      const stateQ = String(req.query.state || "");
      if (stateQ) {
        const states = xsDevOauth_readJson(xsDevOauth_STATES_FILE, {});
        const st = states[stateQ];
        if (st && st.deviceId) {
          const deviceId = st.deviceId;

          const redirect_uri =
            process.env.SORARE_OAUTH_REDIRECT ||
            process.env.SORARE_OAUTH_REDIRECT_URI ||
            "http://localhost:3000/auth/sorare/callback";

          if (!xsDevOauth_CLIENT_ID || !xsDevOauth_CLIENT_SECRET) {
            return res.status(500).json({ error: "Missing env client id/secret for device oauth" });
          }

          const codeQ = String(req.query.code || "");
          if (!codeQ) return res.status(400).send("Missing code");

          const token = await xsDevOauth_tokenRequest({
            grant_type: "authorization_code",
            code: codeQ,
            client_id: xsDevOauth_CLIENT_ID,
            client_secret: xsDevOauth_CLIENT_SECRET,
            redirect_uri: redirect_uri,
          });

          const accessToken = token.access_token;
          if (!accessToken) return res.status(500).send("No access_token received");

          const me = await xsDevOauth_graphql(accessToken, "query { currentUser { slug nickname } }", {});
          const cu = me && me.data && me.data.currentUser ? me.data.currentUser : null;
          if (!cu || !cu.slug) return res.status(500).send("Unable to read currentUser");

          const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
          devices[deviceId] = {
            userSlug: cu.slug,
            nickname: cu.nickname || null,
            access_token: token.access_token,
            refresh_token: token.refresh_token,
            expires_in: token.expires_in,
            expires_at: xsDevOauth_nowSec() + (token.expires_in || 0),
            linked_at: new Date().toISOString(),
          };
          xsDevOauth_writeJson(xsDevOauth_DEVICES_FILE, devices);

          delete states[stateQ];
          xsDevOauth_writeJson(xsDevOauth_STATES_FILE, states);

          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.end("<h2>✅ Connexion Sorare (device) OK</h2><p>Retourne dans l’app. Tu peux fermer cet onglet.</p>");
          return;
        }
      }
    } catch (eBridge) {
      // On ne casse pas le flow existant
      console.warn("[XS_DEVICE_OAUTH_BRIDGE_V1] ignored:", String(eBridge && eBridge.message ? eBridge.message : eBridge));
    }
    // ===== /XS_DEVICE_OAUTH_BRIDGE_V1 =====
try {
    const code = String(req.query.code || "").trim();
    if (!code) return res.status(400).send("Missing ?code=");

    const form = new URLSearchParams();
    form.set("client_id", SORARE_OAUTH_UID);
    form.set("client_secret", SORARE_OAUTH_SECRET);
    form.set("code", code);
    form.set("grant_type", "authorization_code");
    form.set("redirect_uri", SORARE_OAUTH_REDIRECT_URI);

    const r = await _fetchAny("https://api.sorare.com/oauth/token", {
      method: "POST",
      headers: { "content-type": "application/x-www-form-urlencoded" },
      body: form.toString(),
    });

    const raw = await r.text();
    if (!r.ok) return res.status(500).send("Token exchange failed: " + r.status + "\n" + raw);

    const token = JSON.parse(raw);
    writeJson(OAUTH_TOKEN_FILE, token);

    res.send("OK OAuth ✅ Token sauvegardé dans data/sorare_oauth.json. Tu peux fermer cette page.");
  } catch (e) {
    res.status(500).send("Callback error: " + String(e.message || e));
  }
});

app.get("/auth/sorare/status", (req, res) => {
  const t = readOAuthToken();
  res.json({
    hasAuth: hasSorareAuth(),
    hasApiKey: Boolean(SORARE_APIKEY),
    hasJwt: Boolean(SORARE_JWT),
    hasOAuthToken: Boolean(t && t.access_token),
    scope: t?.scope || null,
    created_at: t?.created_at || null,
  });
});
/* ===== /OAuth Sorare ===== */
/* ===== OAuth Sorare (Injected) ===== */

// Reads env at runtime (dotenv already loaded in your file)
const SORARE_OAUTH_UID = process.env.SORARE_OAUTH_UID || "";
const SORARE_OAUTH_SECRET = process.env.SORARE_OAUTH_SECRET || "";
const SORARE_OAUTH_REDIRECT_URI = process.env.SORARE_OAUTH_REDIRECT_URI || "http://localhost:3000/auth/sorare/callback";
const OAUTH_TOKEN_FILE = dataFile("sorare_oauth.json");

function readOAuthToken() {
  return readJson(OAUTH_TOKEN_FILE, null);
}

function hasSorareAuth() {
  const t = readOAuthToken();
  return Boolean(SORARE_APIKEY || SORARE_JWT || (t && t.access_token));
}

// Override sorareHeaders safely (no regex edit inside old function)
function sorareHeaders() {
  const h = { "content-type": "application/json", "accept": "application/json" };

  if (SORARE_JWT) h["authorization"] = "Bearer " + SORARE_JWT;
  
  if (SORARE_JWT_AUD) h["JWT-AUD"] = SORARE_JWT_AUD;
if (SORARE_APIKEY) {
    // keep compatibility with existing code
    h["APIKEY"] = SORARE_APIKEY;
    h["X-API-Key"] = SORARE_APIKEY;
  }

  if (!h["authorization"] && !SORARE_APIKEY) {
    const t = readOAuthToken();
    if (t && t.access_token) h["authorization"] = "Bearer " + t.access_token;
  }

  return h;
}

function _fetchAny(...args) {
  if (typeof fetch === "function") return fetch(...args);
  return import("node-fetch").then(m => m.default(...args));
}

// Auth entrypoint (redirect to Sorare)
app.get("/auth/sorare", (req, res) => {
  if (!SORARE_OAUTH_UID || !SORARE_OAUTH_SECRET) {
    return res.status(400).json({ error: "OAuth non configuré: SORARE_OAUTH_UID/SECRET manquants" });
  }
  const u = encodeURIComponent(SORARE_OAUTH_UID);
  const r = encodeURIComponent(SORARE_OAUTH_REDIRECT_URI);
  const url = `https://sorare.com/oauth/authorize?client_id=${u}&redirect_uri=${r}&response_type=code&scope=public`;
  res.redirect(url);
});

// Callback: exchange code -> token
app.get("/auth/sorare/callback", async (req, res) => {
  
    // ===== XS_DEVICE_OAUTH_BRIDGE_V1 =====
    // Si ce callback reçoit un state généré par /auth/sorare-device/login,
    // on stocke un token PAR deviceId dans oauth_devices.json, puis on return.
    try {
      const stateQ = String(req.query.state || "");
      if (stateQ) {
        const states = xsDevOauth_readJson(xsDevOauth_STATES_FILE, {});
        const st = states[stateQ];
        if (st && st.deviceId) {
          const deviceId = st.deviceId;

          const redirect_uri =
            process.env.SORARE_OAUTH_REDIRECT ||
            process.env.SORARE_OAUTH_REDIRECT_URI ||
            "http://localhost:3000/auth/sorare/callback";

          if (!xsDevOauth_CLIENT_ID || !xsDevOauth_CLIENT_SECRET) {
            return res.status(500).json({ error: "Missing env client id/secret for device oauth" });
          }

          const codeQ = String(req.query.code || "");
          if (!codeQ) return res.status(400).send("Missing code");

          const token = await xsDevOauth_tokenRequest({
            grant_type: "authorization_code",
            code: codeQ,
            client_id: xsDevOauth_CLIENT_ID,
            client_secret: xsDevOauth_CLIENT_SECRET,
            redirect_uri: redirect_uri,
          });

          const accessToken = token.access_token;
          if (!accessToken) return res.status(500).send("No access_token received");

          const me = await xsDevOauth_graphql(accessToken, "query { currentUser { slug nickname } }", {});
          const cu = me && me.data && me.data.currentUser ? me.data.currentUser : null;
          if (!cu || !cu.slug) return res.status(500).send("Unable to read currentUser");

          const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
          devices[deviceId] = {
            userSlug: cu.slug,
            nickname: cu.nickname || null,
            access_token: token.access_token,
            refresh_token: token.refresh_token,
            expires_in: token.expires_in,
            expires_at: xsDevOauth_nowSec() + (token.expires_in || 0),
            linked_at: new Date().toISOString(),
          };
          xsDevOauth_writeJson(xsDevOauth_DEVICES_FILE, devices);

          delete states[stateQ];
          xsDevOauth_writeJson(xsDevOauth_STATES_FILE, states);

          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.end("<h2>✅ Connexion Sorare (device) OK</h2><p>Retourne dans l’app. Tu peux fermer cet onglet.</p>");
          return;
        }
      }
    } catch (eBridge) {
      // On ne casse pas le flow existant
      console.warn("[XS_DEVICE_OAUTH_BRIDGE_V1] ignored:", String(eBridge && eBridge.message ? eBridge.message : eBridge));
    }
    // ===== /XS_DEVICE_OAUTH_BRIDGE_V1 =====
try {
    const code = String(req.query.code || "").trim();
    if (!code) return res.status(400).send("Missing ?code=");

    const form = new URLSearchParams();
    form.set("client_id", SORARE_OAUTH_UID);
    form.set("client_secret", SORARE_OAUTH_SECRET);
    form.set("code", code);
    form.set("grant_type", "authorization_code");
    form.set("redirect_uri", SORARE_OAUTH_REDIRECT_URI);

    const r = await _fetchAny("https://api.sorare.com/oauth/token", {
      method: "POST",
      headers: { "content-type": "application/x-www-form-urlencoded" },
      body: form.toString(),
    });

    const raw = await r.text();
    if (!r.ok) return res.status(500).send("Token exchange failed: " + r.status + "\n" + raw);

    const token = JSON.parse(raw);
    writeJson(OAUTH_TOKEN_FILE, token);

    res.send("OK OAuth ✅ Token sauvegardé dans data/sorare_oauth.json. Tu peux fermer cette page.");
  } catch (e) {
    res.status(500).send("Callback error: " + String(e.message || e));
  }
});

// Status endpoint
app.get("/auth/sorare/status", (req, res) => {
  const t = readOAuthToken();
  res.json({
    hasAuth: hasSorareAuth(),
    hasApiKey: Boolean(SORARE_APIKEY),
    hasJwt: Boolean(SORARE_JWT),
    hasOAuthToken: Boolean(t && t.access_token),
    scope: t?.scope || null,
    created_at: t?.created_at || null,
  });
});

/* ===== /OAuth Sorare (Injected) ===== */

// XS_DEBUG_ERROR_MW (dev only)
app.use((err, req, res, next) => {
  try { console.error('[UNHANDLED]', err && err.stack ? err.stack : err); } catch (e) {}
  try {
    res.status(500).json({ error: 'Internal Server Error', message: String(err && err.message ? err.message : err) });
  } catch (e) { try { res.status(500).end(); } catch(_) {} }
});

  // XS_PUBLIC_PLAYER2 (debug endpoint)
  app.get("/public-player2", async (req, res) => {
    try {
      const slug = String(req.query.slug || "").trim();
      if (!slug) return res.status(400).json({ error: "slug missing" });

      const url = "https://api.sorare.com/graphql";
      const query = `
        query PublicPlayer($slug: String!) {
          football {
            player(slug: $slug) {
              slug
              displayName
              anyPositions
              activeClub { name slug }
            }
          }
        }
      `;
      const variables = { slug };

      const r = await fetch(url, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "accept": "application/json",
        },
        body: JSON.stringify({ query, variables }),
      });

      const text = await r.text();

      if (!r.ok) {
        return res.status(502).json({
          error: "Sorare upstream error",
          status: r.status,
          body: text.slice(0, 3000),
        });
      }

      let json;
      try { json = JSON.parse(text); }
      catch {
        return res.status(502).json({
          error: "Sorare returned non-JSON",
          body: text.slice(0, 3000),
        });
      }

      if (json.errors) {
        return res.status(502).json({
          error: "Sorare GraphQL errors",
          errors: json.errors,
        });
      }

      const p = json && json.data && json.data.football ? json.data.football.player : null;
      if (!p) return res.status(404).json({ error: "player not found", slug, data: (json && json.data) ? json.data : null });

      const position = Array.isArray(p.anyPositions) && p.anyPositions[0] ? ((typeof p.anyPositions[0]==="string"?p.anyPositions[0]:(p.anyPositions[0]&&p.anyPositions[0].position)) || null) : null;

      return res.json({
        playerSlug: p.slug,
        playerName: p.displayName || p.slug,
        position,
        activeClub: p.activeClub ? { name: p.activeClub.name, slug: p.activeClub.slug } : null,
        raw: p,
      });

    } catch (e) {
      console.error("[public-player2] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String((e && e.message) ? e.message : e) });
    }
  });
  // XS_SCOUT_SEARCH (schema-robust; dev)
  // usage: /scout/search?q=mbappe&first=10
  // XS_SCOUT_SEARCH_V2 (players list; schema-robust)
  // usage: /scout/search?q=mbappe&first=10
  // XS_SCOUT_SEARCH_VIA_CARDS (robust; uses /scout/cards + cache)
  // usage: /scout/search?q=mbappe&first=10&eurOnly=1
  // XS_SCOUT_SEARCH_V2 (filter + enrich; robust even when scout/cards falls back cache)
  // usage: /scout/search?q=mbappe&first=10&eurOnly=1&pool=200
  // XS_SCOUT_SEARCH_GRAPHQL (no introspection; tries shapes on searchCards)
  // usage: /scout/search?q=mbappe&first=10
  // XS_SCOUT_SEARCH_WRAPPER (stable)
  // Strategy:
  //  - if q looks like a slug => /public-player
  //  - else => try /scout/search-cached (filter+enrich)
  //  - if cache is non-exact and no matches => 503 with hint (avoid noisy results)
  //  - fallback => /scout/search-cards-v1 (older via-cards)
  app.get("/scout/search", async (req, res) => {
    try {
      const qRaw0 = String(req.query.q || "").trim();

// Accept full Sorare player URL pasted by user and extract slug
function extractPlayerSlugFromText(s) {
  if (!s) return null;
  const t = String(s).trim();

  // Match common patterns:
  //  - https://sorare.com/football/players/<slug>
  //  - https://sorare.com/players/<slug>
  //  - https://sorare.com/player/<slug>
  //  - also accept query strings after slug
  const m =
    t.match(/sorare\.com\/(?:football\/)?players\/([a-z0-9\-_.]+)/i) ||
    t.match(/sorare\.com\/player\/([a-z0-9\-_.]+)/i);

  return m ? m[1] : null;
}

const extractedSlug = extractPlayerSlugFromText(qRaw0);
const qRaw = extractedSlug || qRaw0;const first = Math.max(1, Math.min(25, parseInt(String(req.query.first || "10"), 10) || 10));
      const eurOnly = String(req.query.eurOnly || "1") === "1" ? "1" : "0";
      const pool = Math.max(25, Math.min(400, parseInt(String(req.query.pool || "200"), 10) || 200));

      if (!qRaw) return res.status(400).json({ error: "q missing" });

      const base = req.protocol + "://" + req.get("host");

      async function fetchJson(url) {
        const r = await fetch(url, { headers: { "accept": "application/json" } });
        const text = await r.text();
        let json = null;
        try { json = JSON.parse(text); } catch {}
        return { ok: r.ok && !!json, status: r.status, json, text: text.slice(0, 2000), url };
      }

      // (A) direct slug -> public-player
      const looksLikeSlug = /^[a-z0-9][a-z0-9\-_.]{2,}$/.test(qRaw) && qRaw.indexOf(" ") === -1;
      if (looksLikeSlug) {
        const p = await fetchJson(`${base}/public-player?slug=${encodeURIComponent(qRaw)}`);
        if (p.ok) {
          const it = p.json;
          return res.json({
            q: qRaw,
            mode: "direct-public-player",
            count: 1,
            items: [{
              slug: it.playerSlug,
              displayName: it.playerName,
              position: it.position || null,
              activeClub: it.activeClub || null,
            }]
          });
        }
      }

      // (B) try cached filter+enrich endpoint (your v2)
      const cached = await fetchJson(`${base}/scout/search-cached?q=${encodeURIComponent(qRaw)}&first=${first}&eurOnly=${eurOnly}&pool=${pool}`);
      if (cached.ok) {
        const count = Number(cached.json?.count || 0);
        const aFromCache = !!cached.json?.source?.a?.fromCache;
        const aCacheExact = !!cached.json?.source?.a?.cacheExact;

        // If we have matches, return them
        if (count > 0) return res.json(cached.json);

        // If empty because non-exact cache => do NOT return random stuff; ask for slug
        if (aFromCache && !aCacheExact) {
          return res.status(503).json({
            error: "search unavailable (public API limited / cache non exact)",
            q: qRaw,
            hint: "Utilise le slug Sorare du joueur. Exemple Mbappé: kylian-mbappe-lottin. Test: /public-player?slug=<slug>",
            cachedSource: cached.json?.source || null
          });
        }

        // Otherwise return empty cleanly
        return res.json(cached.json);
      }

      // (C) fallback older via-cards
      const v1 = await fetchJson(`${base}/scout/search-cards-v1?q=${encodeURIComponent(qRaw)}&first=${first}&eurOnly=${eurOnly}`);
      if (v1.ok) return res.json(v1.json);

      // (D) last: whatever you currently have in /scout/search-impl
      const impl = await fetchJson(`${base}/scout/search-impl?q=${encodeURIComponent(qRaw)}&first=${first}&eurOnly=${eurOnly}&pool=${pool}`);
      if (impl.ok) return res.json(impl.json);

      return res.status(502).json({
        error: "scout/search failed (all strategies)",
        q: qRaw,
        details: [
          { tried: "public-player", ok: false },
          { tried: "search-cached", ok: cached.ok, status: cached.status },
          { tried: "search-cards-v1", ok: v1.ok, status: v1.status },
          { tried: "search-impl", ok: impl.ok, status: impl.status }
        ],
      });

    } catch (e) {
      console.error("[scout/search wrapper] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  app.get("/scout/search-impl", async (req, res) => {
    try {
      const qRaw = String(req.query.q || "").trim();
      const first = Math.max(1, Math.min(25, parseInt(String(req.query.first || "10"), 10) || 10));
      if (!qRaw) return res.status(400).json({ error: "q missing" });

      const base = req.protocol + "://" + req.get("host");

      // If it looks like a slug, try direct public-player first (works for kylian-mbappe-lottin)
      const looksLikeSlug = /^[a-z0-9][a-z0-9\-_.]{2,}$/.test(qRaw) && qRaw.indexOf(" ") === -1;
      if (looksLikeSlug) {
        try {
          const rP = await fetch(`${base}/public-player?slug=${encodeURIComponent(qRaw)}`, { headers: { "accept": "application/json" } });
          if (rP.ok) {
            const p = await rP.json();
            return res.json({
              q: qRaw,
              mode: "direct-public-player",
              count: 1,
              items: [{
                slug: p.playerSlug,
                displayName: p.playerName,
                position: p.position || null,
                activeClub: p.activeClub || null,
              }],
            });
          }
        } catch {}
      }

      const url = "https://api.sorare.com/graphql";

      async function gqlTry(query, variables) {
        const r = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json", "accept": "application/json" },
          body: JSON.stringify({ query, variables }),
        });
        const text = await r.text();
        let json = null;
        try { json = JSON.parse(text); } catch {}
        const ok = r.ok && json && !json.errors;
        return { ok, status: r.status, json, text: text.slice(0, 2500) };
      }

      function positionFromAny(anyPositions) {
        if (Array.isArray(anyPositions) && anyPositions[0]) {
          return (typeof anyPositions[0] === "string") ? anyPositions[0] : (anyPositions[0] && anyPositions[0].position);
        }
        return null;
      }

      function isBasketball(anyPositions, position) {
        const p = (position || "").toLowerCase();
        if (p.startsWith("basketball_")) return true;
        if (Array.isArray(anyPositions) && anyPositions[0] && String(anyPositions[0]).toLowerCase().startsWith("basketball_")) return true;
        return false;
      }

      function pullPlayersFromCardNodes(nodes) {
        const out = [];
        const arr = Array.isArray(nodes) ? nodes : [];
        for (const n of arr) {
          const card = n?.card ? n.card : n; // support {card{...}} or direct card
          const player = card?.player || card?.anyPlayer || null;
          if (!player?.slug) continue;

          const pos = positionFromAny(player.anyPositions);
          if (isBasketball(player.anyPositions, pos)) continue;

          out.push({
            slug: player.slug,
            displayName: player.displayName || player.slug,
            position: pos || null,
            activeClub: player.activeClub ? { name: player.activeClub.name, slug: player.activeClub.slug } : null,
          });
        }
        return out;
      }

      const variables = { q: qRaw };

      // Try multiple shapes for SearchCardHits
      const candidates = [
        {
          name: "searchCards{cards}",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                __typename
                cards {
                  __typename
                  player { slug displayName anyPositions activeClub { name slug } }
                }
              }
            }
          `,
          pick: (j) => j?.data?.searchCards?.cards,
        },
        {
          name: "searchCards{hits}",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                __typename
                hits {
                  __typename
                  card {
                    __typename
                    anyPlayer { slug displayName anyPositions activeClub { name slug } }
                  }
                }
              }
            }
          `,
          pick: (j) => (j?.data?.searchCards?.hits || []).map(h => h?.card).filter(Boolean),
        },
        {
          name: "searchCards{items}",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                __typename
                items {
                  __typename
                  card {
                    __typename
                    player { slug displayName anyPositions activeClub { name slug } }
                  }
                }
              }
            }
          `,
          pick: (j) => (j?.data?.searchCards?.items || []).map(h => h?.card).filter(Boolean),
        },
        {
          name: "searchCards{results}",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                __typename
                results {
                  __typename
                  card {
                    __typename
                    player { slug displayName anyPositions activeClub { name slug } }
                  }
                }
              }
            }
          `,
          pick: (j) => (j?.data?.searchCards?.results || []).map(h => h?.card).filter(Boolean),
        },
        {
          name: "searchCards{edges{node}}",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                __typename
                edges {
                  __typename
                  node {
                    __typename
                    ... on AnyCard { player { slug displayName anyPositions activeClub { name slug } } }
                    ... on Card    { player { slug displayName anyPositions activeClub { name slug } } }
                  }
                }
              }
            }
          `,
          pick: (j) => (j?.data?.searchCards?.edges || []).map(e => e?.node).filter(Boolean),
        },
      ];

      const attempts = [];
      for (const c of candidates) {
        const r = await gqlTry(c.query, variables);
        attempts.push({
          name: c.name,
          status: r.status,
          ok: r.ok,
          error0: r.json?.errors?.[0]?.message || null,
          typename: r.json?.data?.searchCards?.__typename || null,
        });

        if (!r.ok) continue;

        const nodes = c.pick(r.json) || [];
const players = pullPlayersFromCardNodes(nodes);

// XS_DEBUG_SAMPLE (only when empty)
const debugSample =
  (players && players.length) ? null :
  (Array.isArray(r.json?.data?.searchCards?.hits) ? r.json.data.searchCards.hits.slice(0, 3) : (Array.isArray(nodes) ? nodes.slice(0,3) : null));

        // Dedup by slug
        const map = new Map();
        for (const p of players) {
          if (!p?.slug) continue;
          if (!map.has(p.slug)) map.set(p.slug, p);
        }

        const items = Array.from(map.values()).slice(0, first);
        return res.json({
          q: qRaw,
          mode: "graphql-searchCards",
          debugSample,
          engine: c.name,
          count: items.length,
          items,
          attempts,
        });
      }

      return res.status(502).json({
        error: "scout/search failed (no matching searchCards shape)",
        q: qRaw,
        attempts,
        hint: "Copie attempts[].error0 : on ajustera le shape gagnant (cards/hits/items/results/edges...).",
      });

    } catch (e) {
      console.error("[scout/search graphql] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  app.get("/scout/search-cached", async (req, res) => {
    try {
      const qRaw = String(req.query.q || "").trim();
      const first = Math.max(1, Math.min(25, parseInt(String(req.query.first || "10"), 10) || 10));
      const eurOnly = String(req.query.eurOnly || "1") === "1" ? "1" : "0";
      const pool = Math.max(25, Math.min(400, parseInt(String(req.query.pool || "200"), 10) || 200));

      if (!qRaw) return res.status(400).json({ error: "q missing" });

      const base = req.protocol + "://" + req.get("host");

      // normalize helper (lower + remove accents)
      function norm(s) {
        if (!s) return "";
        return String(s)
          .toLowerCase()
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "");
      }

      const q = norm(qRaw);
      const qTokens = q.split(/[\s\-_.]+/g).filter(t => t.length >= 3);

      // 1) If q looks like a slug, try directly /public-player first
      const looksLikeSlug = /^[a-z0-9][a-z0-9\-_.]{2,}$/.test(q) && q.indexOf(" ") === -1;
      if (looksLikeSlug) {
        try {
          const rP = await fetch(`${base}/public-player?slug=${encodeURIComponent(qRaw)}`, { headers: { "accept": "application/json" } });
          if (rP.ok) {
            const p = await rP.json();
            return res.json({
              q: qRaw,
              mode: "direct-public-player",
              count: 1,
              items: [{
                slug: p.playerSlug,
                displayName: p.playerName,
                position: p.position || null,
                activeClub: p.activeClub || null,
              }],
            });
          }
        } catch {}
      }

      // 2) Get pool from /scout/cards?q=...
      async function getCards(queryString) {
        const url = `${base}/scout/cards?first=${pool}&eurOnly=${eurOnly}${queryString ? `&q=${encodeURIComponent(queryString)}` : ""}`;
        const r = await fetch(url, { headers: { "accept": "application/json" } });
        const text = await r.text();
        let json = null;
        try { json = JSON.parse(text); } catch {}
        return { ok: r.ok && !!json, status: r.status, json, text: text.slice(0, 1500), url };
      }

      const a = await getCards(qRaw);
      let offers = Array.isArray(a.json?.items) ? a.json.items : [];
      let fromCache = !!a.json?.fromCache;
      let cacheExact = !!a.json?.cacheExact;

      // 3) If cache was not exact, add a no-q pool to filter locally
      let b = null;
      if (fromCache && !cacheExact) {
        b = await getCards("");
        const offers2 = Array.isArray(b.json?.items) ? b.json.items : [];
        offers = offers.concat(offers2);
      }

      // 4) Build candidate players from offers then FILTER locally
      const map = new Map();

      function readSlug(it) {
        return it.playerSlug || it.player?.slug || it.card?.player?.slug || it.cardPlayerSlug || null;
      }
      function readName(it, slug) {
        return it.playerName || it.player?.displayName || it.card?.player?.displayName || it.cardPlayerName || slug;
      }
      function readPosition(it) {
        return it.position || it.player?.position || it.card?.player?.position || null;
      }

      function matchesQ(slug, name) {
        const s = norm(slug);
        const n = norm(name);
        if (!qTokens.length) return (s.includes(q) || n.includes(q));
        // require ALL tokens to appear somewhere (slug or name)
        return qTokens.every(t => (s.includes(t) || n.includes(t)));
      }

      for (const it of offers) {
        const slug = readSlug(it);
        if (!slug) continue;
        const name = readName(it, slug);
        const pos = readPosition(it);

        // exclude basketball noise
        if (typeof pos === "string" && pos.toLowerCase().startsWith("basketball_")) continue;

        if (!matchesQ(slug, name)) continue;

        if (!map.has(slug)) {
          map.set(slug, {
            slug,
            displayName: name || slug,
            position: pos || null,
            activeClub: null,
            offersCount: 1,
          });
        } else {
          map.get(slug).offersCount += 1;
        }
      }

      const rawItems = Array.from(map.values());

      // 5) Enrich with /public-player (position + activeClub), limited to `first`
      const items = [];
      for (const it of rawItems.slice(0, first)) {
        try {
          const rP = await fetch(`${base}/public-player?slug=${encodeURIComponent(it.slug)}`, { headers: { "accept": "application/json" } });
          if (rP.ok) {
            const p = await rP.json();
            items.push({
              slug: it.slug,
              displayName: p.playerName || it.displayName,
              position: p.position || it.position || null,
              activeClub: p.activeClub || null,
              offersCount: it.offersCount,
            });
            continue;
          }
        } catch {}
        items.push(it);
      }

      return res.json({
        q: qRaw,
        mode: "via-scout-cards-filter-enrich",
        first,
        pool,
        eurOnly: eurOnly === "1",
        count: items.length,
        items,
        source: {
          a: { fromCache, cacheExact, note: a.json?.note || null },
          b: b ? { fromCache: !!b.json?.fromCache, cacheExact: !!b.json?.cacheExact, note: b.json?.note || null } : null,
        },
        debug: {
          offersInA: Array.isArray(a.json?.items) ? a.json.items.length : 0,
          offersTotal: offers.length,
          rawMatches: rawItems.length,
        }
      });

    } catch (e) {
      console.error("[scout/search v2] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  app.get("/scout/search-cards-v1", async (req, res) => {
    try {
      const q = String(req.query.q || "").trim();
      const first = Math.max(1, Math.min(50, parseInt(String(req.query.first || "10"), 10) || 10));
      const eurOnly = String(req.query.eurOnly || "1") === "1" ? "1" : "0";

      if (!q) return res.status(400).json({ error: "q missing" });

      // Call our own /scout/cards (so we benefit from your existing cache/fallback logic)
      const base = req.protocol + "://" + req.get("host");
      const url = `${base}/scout/cards?first=${first}&eurOnly=${eurOnly}&q=${encodeURIComponent(q)}`;

      const r = await fetch(url, { headers: { "accept": "application/json" } });
      const text = await r.text();

      let json = null;
      try { json = JSON.parse(text); } catch {}

      if (!r.ok || !json) {
        return res.status(502).json({
          error: "scout/search failed (via scout/cards)",
          status: r.status,
          body: text.slice(0, 2000),
        });
      }

      const offers = Array.isArray(json.items) ? json.items : [];
      const map = new Map();

      for (const it of offers) {
        // Try to detect slug/name in multiple shapes
        const slug =
          it.playerSlug ||
          it.player?.slug ||
          it.card?.player?.slug ||
          it.cardPlayerSlug ||
          null;

        const name =
          it.playerName ||
          it.player?.displayName ||
          it.card?.player?.displayName ||
          it.cardPlayerName ||
          slug;

        if (!slug) continue;

        // Optional: keep some useful hints
        const club =
          it.activeClub ||
          it.player?.activeClub ||
          it.card?.player?.activeClub ||
          null;

        const position =
          it.position ||
          it.player?.position ||
          it.card?.player?.position ||
          null;

        const key = slug;
        if (!map.has(key)) {
          map.set(key, {
            slug,
            displayName: name || slug,
            position: position || null,
            activeClub: club ? { name: club.name, slug: club.slug } : null,
            offersCount: 1,
          });
        } else {
          map.get(key).offersCount += 1;
        }
      }

      const items = Array.from(map.values()).slice(0, first);

      return res.json({
        q,
        first,
        eurOnly: eurOnly === "1",
        count: items.length,
        items,
        source: {
          offersCount: offers.length,
          fromCache: !!json.fromCache,
          cacheExact: !!json.cacheExact,
          note: json.note || null,
        },
      });

    } catch (e) {
      console.error("[scout/search via cards] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  app.get("/scout/search-gql", async (req, res) => {
    try {
      const q = String(req.query.q || "").trim();
      const first = Math.max(1, Math.min(25, parseInt(String(req.query.first || "10"), 10) || 10));
      if (!q) return res.status(400).json({ error: "q missing" });

      const url = "https://api.sorare.com/graphql";

      async function gqlTry(query, variables) {
        const r = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json", "accept": "application/json" },
          body: JSON.stringify({ query, variables }),
        });
        const text = await r.text();
        let json = null;
        try { json = JSON.parse(text); } catch {}
        const ok = r.ok && json && !json.errors;
        return { ok, json, text, status: r.status };
      }

      function normItem(slug, displayName, activeClub, anyPositions) {
        const position =
          Array.isArray(anyPositions) && anyPositions[0]
            ? (typeof anyPositions[0] === "string" ? anyPositions[0] : (anyPositions[0] && anyPositions[0].position))
            : null;

        return {
          slug: slug || null,
          displayName: displayName || slug || null,
          position,
          activeClub: activeClub ? { name: activeClub.name, slug: activeClub.slug } : null,
        };
      }

      const variables = { q, first };

      const candidates = [
        {
          name: "football.players(list, query)",
          query: `
            query ScoutSearch($q: String!) {
              football {
                players(query: $q, first: $first) {
                  slug
                  displayName
                  anyPositions
                  activeClub { name slug }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.players,
        },
        {
          name: "football.players(list, search)",
          query: `
            query ScoutSearch($q: String!) {
              football {
                players(search: $q, first: $first) {
                  slug
                  displayName
                  anyPositions
                  activeClub { name slug }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.players,
        },
        {
          // in case "first" not supported
          name: "football.players(list, query no-first)",
          query: `
            query ScoutSearch($q: String!) {
              football {
                players(query: $q) {
                  slug
                  displayName
                  anyPositions
                  activeClub { name slug }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.players,
          vars: (v) => ({ q: v.q }),
        },
        {
          // last resort: try "searchCards" (some schemas only expose card search)
          name: "searchCards fallback",
          query: `
            query ScoutSearch($q: String!) {
              searchCards(query: $q) {
                nodes {
                  __typename
                  ... on AnyCard {
                    player { slug displayName anyPositions activeClub { name slug } }
                  }
                  ... on Card {
                    player { slug displayName anyPositions activeClub { name slug } }
                  }
                }
              }
            }
          `,
          pick: (j) => (j?.data?.searchCards?.nodes || [])
            .map(n => n?.player ? n.player : null)
            .filter(Boolean),
        },
      ];

      const attempts = [];

      for (const c of candidates) {
        const vars = c.vars ? c.vars(variables) : variables;
        const r = await gqlTry(c.query, vars);

        attempts.push({
          name: c.name,
          status: r.status,
          hasJson: !!r.json,
          hasErrors: !!(r.json && r.json.errors),
          error0: r.json?.errors?.[0]?.message || null,
        });

        if (r.ok) {
          const nodes = c.pick(r.json) || [];
          const arr = Array.isArray(nodes) ? nodes : [];
          const items = arr.map(n => {
            const slug = n?.slug;
            if (!slug) return null;
            return normItem(slug, n?.displayName, n?.activeClub, n?.anyPositions);
          }).filter(Boolean);

          return res.json({ q, engine: c.name, count: items.length, items, attempts });
        }
      }

      return res.status(502).json({
        error: "scout/search upstream schema mismatch",
        q,
        attempts,
        hint: "Regarde attempts.error0 pour voir le 1er mismatch restant; on ajustera la query gagnante.",
      });

    } catch (e) {
      console.error("[scout/search] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  app.get("/scout/search-old", async (req, res) => {
    try {
      const q = String(req.query.q || "").trim();
      const first = Math.max(1, Math.min(25, parseInt(String(req.query.first || "10"), 10) || 10));
      if (!q) return res.status(400).json({ error: "q missing" });

      const url = "https://api.sorare.com/graphql";

      // Helper: call Sorare GraphQL and return {ok,json,text,status}
      async function gqlTry(query, variables) {
        const r = await fetch(url, {
          method: "POST",
          headers: { "content-type": "application/json", "accept": "application/json" },
          body: JSON.stringify({ query, variables }),
        });
        const text = await r.text();
        let json = null;
        try { json = JSON.parse(text); } catch {}
        const ok = r.ok && json && !json.errors;
        return { ok, json, text, status: r.status };
      }

      // Extract helpers (safe for many shapes)
      function normItem(slug, displayName, activeClub, anyPositions) {
        const position =
          Array.isArray(anyPositions) && anyPositions[0]
            ? (typeof anyPositions[0] === "string" ? anyPositions[0] : (anyPositions[0] && anyPositions[0].position))
            : null;

        return {
          slug: slug || null,
          displayName: displayName || slug || null,
          position,
          activeClub: activeClub ? { name: activeClub.name, slug: activeClub.slug } : null,
        };
      }

      // Candidate queries (try in order)
      const variables = { q, first };

      const candidates = [
        {
          name: "football.players(query)",
          query: `
            query ScoutSearch($q: String!) {
              football {
                players(query: $q, first: $first) {
                  nodes { slug displayName anyPositions activeClub { name slug } }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.players?.nodes,
        },
        {
          name: "football.players(search)",
          query: `
            query ScoutSearch($q: String!) {
              football {
                players(search: $q, first: $first) {
                  nodes { slug displayName anyPositions activeClub { name slug } }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.players?.nodes,
        },
        {
          name: "football.searchPlayers",
          query: `
            query ScoutSearch($q: String!) {
              football {
                searchPlayers(query: $q, first: $first) {
                  nodes { slug displayName anyPositions activeClub { name slug } }
                }
              }
            }
          `,
          pick: (j) => j?.data?.football?.searchPlayers?.nodes,
        },
        {
          // global search fallback (older style)
          name: "search(query)",
          query: `
            query ScoutSearch($q: String!) {
              search(query: $q, first: $first) {
                nodes {
                  __typename
                  ... on FootballPlayer { slug displayName anyPositions activeClub { name slug } }
                  ... on Player { slug displayName anyPositions activeClub { name slug } }
                }
              }
            }
          `,
          pick: (j) => j?.data?.search?.nodes,
        },
      ];

      const attempts = [];
      for (const c of candidates) {
        const r = await gqlTry(c.query, variables);
        attempts.push({
          name: c.name,
          status: r.status,
          hasJson: !!r.json,
          hasErrors: !!(r.json && r.json.errors),
          error0: r.json?.errors?.[0]?.message || null,
        });

        if (r.ok) {
          const nodes = c.pick(r.json) || [];
          const items = (Array.isArray(nodes) ? nodes : [])
            .map(n => {
              // global search nodes may be mixed types
              const slug = n?.slug;
              const displayName = n?.displayName;
              const activeClub = n?.activeClub;
              const anyPositions = n?.anyPositions;
              if (!slug) return null;
              return normItem(slug, displayName, activeClub, anyPositions);
            })
            .filter(Boolean);

          return res.json({
            q,
            engine: c.name,
            count: items.length,
            items,
            attempts,
          });
        }
      }

      return res.status(502).json({
        error: "scout/search upstream schema mismatch",
        q,
        attempts,
        hint: "Aucun candidat n'a matché. On ajustera la query gagnante en lisant 'attempts.error0'.",
      });

    } catch (e) {
      console.error("[scout/search] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });
  // XS_GQL_INTROSPECT (dev)
  // usage:
  //   /debug/gql-type?name=SearchCardHits
  //   /debug/gql-type?name=Query
  app.get("/debug/gql-type", async (req, res) => {
    try {
      const name = String(req.query.name || "").trim();
      if (!name) return res.status(400).json({ error: "name missing" });

      const url = "https://api.sorare.com/graphql";
      const query = `
        query IntrospectType($name: String!) {
          __type(name: $name) {
            name
            kind
            fields(includeDeprecated: true) {
              name
              type {
                kind
                name
                ofType { kind name ofType { kind name } }
              }
            }
            inputFields {
              name
              type { kind name ofType { kind name } }
            }
            enumValues { name }
          }
        }
      `;
      const variables = { name };

      const r = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json", "accept": "application/json" },
        body: JSON.stringify({ query, variables }),
      });

      const text = await r.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}

      if (!r.ok || !json) {
        return res.status(502).json({ error: "upstream error", status: r.status, body: text.slice(0, 3000) });
      }
      if (json.errors) {
        return res.status(502).json({ error: "graphql errors", errors: json.errors });
      }
      return res.json(json.data);
    } catch (e) {
      console.error("[debug/gql-type] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });

  // XS_GQL_INTROSPECT_SCHEMA (dev)
  // usage: /debug/gql-schema
  app.get("/debug/gql-schema", async (req, res) => {
    try {
      const url = "https://api.sorare.com/graphql";
      const query = `
        query IntrospectSchema {
          __schema {
            queryType { name }
            types {
              name
              kind
            }
          }
        }
      `;
      const r = await fetch(url, {
        method: "POST",
        headers: { "content-type": "application/json", "accept": "application/json" },
        body: JSON.stringify({ query }),
      });
      const text = await r.text();
      let json = null;
      try { json = JSON.parse(text); } catch {}
      if (!r.ok || !json) return res.status(502).json({ error: "upstream error", status: r.status, body: text.slice(0,3000) });
      if (json.errors) return res.status(502).json({ error: "graphql errors", errors: json.errors });
      return res.json(json.data);
    } catch (e) {
      console.error("[debug/gql-schema] error:", e && e.stack ? e.stack : e);
      return res.status(500).json({ error: "Internal Server Error", message: String(e?.message || e) });
    }
  });


// XS_MARKET_RESET_V1_BEGIN
// New Market implementation based on Sorare docs (APIKEY + liveSingleSaleOffers)
// - Endpoint: GET /market/offers?last=20
// - Price read via receiverSide.amounts.eur
// - Disk cache + 429 Retry-After passthrough

app.get("/market/offers-old", async (req, res) => {
  const xsFs = require("fs");
  const xsPath = require("path");

  const last = Math.max(1, Math.min(50, parseInt(String(req.query.last || "20"), 10) || 20));
  const cacheFile = xsPath.join(__dirname, "data", "market_cache.json");
  const cacheKey = `offers_last_${last}`;

  const readCache = () => {
    try {
      if (!xsFs.existsSync(cacheFile)) return null;
      const raw = xsFs.readFileSync(cacheFile, "utf8");
      const j = JSON.parse(raw);
      return j && j[cacheKey] ? j[cacheKey] : null;
    } catch {
      return null;
    }
  };

  const writeCache = (payload) => {
    try {
      let j = {};
      if (xsFs.existsSync(cacheFile)) {
        try { j = JSON.parse(xsFs.readFileSync(cacheFile, "utf8")); } catch { j = {}; }
      }
      j[cacheKey] = { ts: Date.now(), payload };
      xsFs.writeFileSync(cacheFile, JSON.stringify(j, null, 2), "utf8");
    } catch {}
  };

  const cached = readCache();

  const query = `
    query LiveSingleSaleOffers($last: Int!) {
      tokens {
        liveSingleSaleOffers(last: $last) {
          nodes {
            id
            status
            senderSide {
              anyCards { assetId slug name rarityTyped collection pictureUrl }
            }
            receiverSide { amounts { eurCents wei } } }
          }
        }
      }
    }
  `;

  const variables = { last };

  const headers = { "content-type": "application/json" };

  // Optional: APIKEY (recommended) -> 600/min
  if (process.env.SORARE_APIKEY) headers["APIKEY"] = process.env.SORARE_APIKEY;

  // Optional: if your server already has user auth tokens somewhere, you can add them here.
  // For now we keep it public + APIKEY.

  try {
    const r = await fetch("https://api.sorare.com/graphql", {
      method: "POST",
      headers,
      body: JSON.stringify({ operationName: "LiveSingleSaleOffers", query, variables }),
    });

    if (r.status === 429) {
      const retryAfter = r.headers.get("retry-after");
      const secs = retryAfter ? parseInt(retryAfter, 10) : null;
      if (cached?.payload) {
        return res.status(200).json({ ok: true, fromCache: true, retryAfterSeconds: secs, ...cached.payload });
      }
      return res.status(429).json({ error: "rate_limited", retryAfterSeconds: secs });
    }

    const json = await r.json().catch(() => null);
    if (!r.ok || !json) {
      if (cached?.payload) return res.status(200).json({ ok: true, fromCache: true, ...cached.payload });
      return res.status(500).json({ error: "sorare_graphql_failed", status: r.status, raw: json });
    }

    const nodes = json?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
    const items = nodes.map((n) => {
      const card = (n?.senderSide?.anyCards && n.senderSide.anyCards[0]) ? n.senderSide.anyCards[0] : null;
      const eur = n?.receiverSide?.amounts?.eur ?? null;
      const wei = n?.receiverSide?.amounts?.wei ?? null;
      return {
        id: n?.id,
        status: n?.status,
        eur,
        wei,
        card: card ? {
          assetId: card.assetId,
          slug: card.slug,
          name: card.name,
          rarity: card.rarityTyped,
          collection: card.collection,
          pictureUrl: card.pictureUrl,
        } : null,
      };
    });

    const payload = { ok: true, fromCache: false, count: items.length, items };
    writeCache(payload);
    return res.json(payload);
  } catch (e) {
    if (cached?.payload) return res.status(200).json({ ok: true, fromCache: true, ...cached.payload });
    return res.status(500).json({ error: "market_offers_exception", message: String(e?.message || e) });
  }
});
// XS_MARKET_RESET_V1_END

// XS_DEVICE_OAUTH_TOKEN_HELPER_V1_BEGIN
function xsGetDeviceOAuthTokenFromDisk(deviceId) {
  try {
    const id = String(deviceId || "").trim();
    if (!id) return null;

    // On évite de dépendre d'un nom de variable précis : on tente DATA_DIR, puis "data" à la racine.
    const dataDir =
      (typeof DATA_DIR !== "undefined" && DATA_DIR) ? DATA_DIR :
      (typeof SCOUT_DATA_DIR !== "undefined" && SCOUT_DATA_DIR) ? SCOUT_DATA_DIR :
      path.join(__dirname, "data");

    const f = path.join(dataDir, "oauth_devices.json");
    if (!fs.existsSync(f)) return null;

    const raw = fs.readFileSync(f, "utf8");
    const j = JSON.parse(raw || "{}");

    const rec = j[id];
    if (!rec) return null;

    const token = rec.access_token || rec.accessToken || null;
    if (!token) return null;

    return {
      token,
      refresh_token: rec.refresh_token || rec.refreshToken || null,
      expires_at: rec.expires_at ?? rec.expiresAt ?? null,
      source: "oauth_devices.json",
      userSlug: rec.userSlug || null,
      nickname: rec.nickname || null,
      linked_at: rec.linked_at || null
    };
  } catch (e) {
    return null;
  }
}
// XS_DEVICE_OAUTH_TOKEN_HELPER_V1_END

// XS_MARKET_OAUTH_RACHEL_V1_BEGIN
app.get("/market/offers", async (req, res) => {
  const deviceId = String(req.query.deviceId || "").trim();
  const last = Math.max(1, Math.min(50, parseInt(String(req.query.last || "20"), 10) || 20));
  if (!deviceId) return res.status(400).json({ error: "deviceId missing" });

  // récupère le token OAuth stocké par deviceId
  const t = xsGetDeviceOAuthTokenFromDisk(deviceId);
  const accessToken = t?.token;
  if (!accessToken) return res.status(401).json({ error: "no_token", tokenSource: t?.source });

  const query = `
    query LiveSingleSaleOffers($last: Int!) {
      tokens {
        liveSingleSaleOffers(last: $last) {
          nodes {
            id
            status
            senderSide { anyCards { slug name rarityTyped collection } }
            receiverSide { amounts { eurCents wei } }
          }
        }
      }
    }
  `;

  try {
    const r = await fetch("https://api.sorare.com/graphql", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "Authorization": "Bearer " + accessToken
      },
      body: JSON.stringify({
        operationName: "LiveSingleSaleOffers",
        query,
        variables: { last }
      })
    });

    const text = await r.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}

    if (!r.ok) {
      return res.status(r.status).json({
        error: "sorare_graphql_failed",
        status: r.status,
        tokenSource: t?.source,
        rawText: text,
        rawJson: json
      });
    }

    const data = json?.data || null;
    const nodes = (((data || {}).tokens || {}).liveSingleSaleOffers || {}).nodes || [];

    const items = nodes.map((n) => {
      const card = n?.senderSide?.anyCards?.[0] || null;
      const eurCents = n?.receiverSide?.amounts?.eurCents ?? null;
      const eur = (eurCents === null || eurCents === undefined) ? null : (Number(eurCents) / 100);
      const wei = n?.receiverSide?.amounts?.wei ?? null;

      return {
        id: n?.id ?? null,
        status: n?.status ?? null,
        cardSlug: card?.slug ?? null,
        cardName: card?.name ?? null,
        rarity: card?.rarityTyped ?? null,
        collection: card?.collection ?? null,
        eur,
        wei
      };
    });

    return res.json({ ok: true, fromCache: false, count: items.length, items });
  } catch (e) {
    return res.status(500).json({ error: "market_offers_exception", message: String(e?.message || e) });
  }
});
// XS_MARKET_OAUTH_RACHEL_V1_END

// XS_MARKET_RAW_V1_BEGIN
app.get("/market/offers-raw", async (req, res) => {
  const deviceId = String(req.query.deviceId || "").trim();
  const last = Math.max(1, Math.min(50, parseInt(String(req.query.last || "20"), 10) || 20));
  if (!deviceId) return res.status(400).json({ error: "deviceId missing" });

  const t = xsGetDeviceOAuthTokenFromDisk(deviceId);
  const accessToken = t?.token;
  if (!accessToken) return res.status(401).json({ error: "no_token", tokenSource: t?.source });

  const query = `
    query LiveSingleSaleOffers($last: Int!) {
      tokens {
        liveSingleSaleOffers(last: $last) {
          nodes {
            id
            status
            senderSide { anyCards { slug name rarityTyped collection } }
            receiverSide { amounts { eurCents wei } }
          }
        }
      }
    }
  `;

  try {
    const r = await fetch("https://api.sorare.com/graphql", {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "Authorization": "Bearer " + accessToken,
      },
      body: JSON.stringify({ operationName: "LiveSingleSaleOffers", query, variables: { last } }),
    });

    const text = await r.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}
    return res.status(r.status).json({ status: r.status, tokenSource: t?.source, rawText: text, rawJson: json });
  } catch (e) {
    return res.status(500).json({ error: "offers_raw_exception", message: String(e?.message || e) });
  }
});
// XS_MARKET_RAW_V1_END

// XS_DEVICE_DEBUG_V1_BEGIN
app.get("/auth/device-debug", (req, res) => {
  const path = require("path"); const fs = require("fs"); try {
    const deviceId = String(req.query.deviceId || "").trim();

    const dataDir =
      (typeof DATA_DIR !== "undefined" && DATA_DIR) ? DATA_DIR :
      (typeof SCOUT_DATA_DIR !== "undefined" && SCOUT_DATA_DIR) ? SCOUT_DATA_DIR :
      path.join(__dirname, "data");

    const f = path.join(dataDir, "oauth_devices.json");
    const exists = fs.existsSync(f);

    let keys = [];
    let rec = null;
    let hasToken = false;

    if (exists) {
      const raw = fs.readFileSync(f, "utf8");
      const j = JSON.parse(raw || "{}");
      keys = Object.keys(j || {});
      rec = deviceId ? (j[deviceId] || null) : null;
      const token = rec?.access_token || rec?.accessToken || null;
      hasToken = !!token;
    }

    return res.json({
      ok: true,
      deviceId,
      dataDir,
      file: f,
      exists,
      keysCount: keys.length,
      keysSample: keys.slice(0, 10),
      found: !!rec,
      hasToken
    });
  } catch (e) {
    return res.status(500).json({ error: "device_debug_exception", message: String(e?.message || e) });
  }
});
// XS_DEVICE_DEBUG_V1_END

// XS_GET_DEVICE_TOKEN_HELPER_V2_BEGIN
function xsGetDeviceOAuthTokenFromDisk(deviceId) {
  try {
    const fs = require("fs");
    const path = require("path");
    const id = String(deviceId || "").trim();
    if (!id) return null;

    const f = path.join(__dirname, "data", "oauth_devices.json");
    if (!fs.existsSync(f)) return null;

    const raw = fs.readFileSync(f, "utf8");
    const j = JSON.parse(raw || "{}");
    const rec = j?.[id] || null;
    if (!rec) return null;

    const token = rec.access_token || rec.accessToken || null;
    if (!token) return null;

    return { token, source: "oauth_devices.json" };
  } catch {
    return null;
  }
}
// XS_GET_DEVICE_TOKEN_HELPER_V2_END
app.listen(PORT, HOST, () => {
  console.log(`[OK] Companion backend on http://${HOST}:${PORT}`);
  console.log(`[OK] GraphQL -> ${SORARE_GQL}`);
});































// ===== XS_DEVICE_OAUTH_V1 =====
// OAuth Sorare par deviceId (MVP dev) - ajout parallèle (ne remplace rien)

const xsDevOauth_DATA_DIR =
  (typeof DATA_DIR !== "undefined" ? DATA_DIR : require("path").join(__dirname, "data"));
const xsDevOauth_DEVICES_FILE = require("path").join(xsDevOauth_DATA_DIR, "oauth_devices.json"); // deviceId -> token + user
const xsDevOauth_STATES_FILE  = require("path").join(xsDevOauth_DATA_DIR, "oauth_states.json");  // state -> deviceId

function xsDevOauth_readJson(file, fallback) {
  try { return JSON.parse(require("fs").readFileSync(file, "utf8")); }
  catch { return fallback; }
}
function xsDevOauth_writeJson(file, obj) {
  const fs2 = require("fs");
  if (!fs2.existsSync(xsDevOauth_DATA_DIR)) fs2.mkdirSync(xsDevOauth_DATA_DIR, { recursive: true });
  fs2.writeFileSync(file, JSON.stringify(obj, null, 2), "utf8");
}
function xsDevOauth_nowSec() { return Math.floor(Date.now() / 1000); }

const xsDevOauth_CLIENT_ID =
  process.env.SORARE_OAUTH_CLIENT_ID || process.env.SORARE_OAUTH_CLIENTID || process.env.SORARE_CLIENT_ID || "";
const xsDevOauth_CLIENT_SECRET =
  process.env.SORARE_OAUTH_CLIENT_SECRET || process.env.SORARE_OAUTH_CLIENTSECRET || process.env.SORARE_CLIENT_SECRET || "";
const xsDevOauth_REDIRECT =
  process.env.SORARE_OAUTH_REDIRECT || process.env.SORARE_OAUTH_REDIRECT_URI || "http://localhost:3000/auth/sorare-device/callback";

async function xsDevOauth_tokenRequest(params) {
  const body = new URLSearchParams(params).toString();
  const r = await fetch("https://api.sorare.com/oauth/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: body,
  });
  let json = {};
  try { json = await r.json(); } catch { json = {}; }
  if (!r.ok) throw new Error("xsDevOauth oauth/token " + r.status + ": " + JSON.stringify(json));
  return json;
}

async function xsDevOauth_graphql(accessToken, query, variables) {
  const r = await fetch("https://api.sorare.com/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + accessToken,
    },
    body: JSON.stringify({ query: query, variables: variables }),
  });
  let json = {};
  try { json = await r.json(); } catch { json = {}; }
  if (!r.ok) throw new Error("xsDevOauth GraphQL " + r.status + ": " + JSON.stringify(json));
  return json;
}

async function xsDevOauth_getTokenForDevice(deviceId) {
  if (!deviceId) return null;
  const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
  const rec = devices[deviceId];
  if (!rec) return null;

  const exp = rec.expires_at || 0;
  if (rec.access_token && exp > (xsDevOauth_nowSec() + 60)) return rec.access_token;

  if (!rec.refresh_token) return null;
  if (!xsDevOauth_CLIENT_ID || !xsDevOauth_CLIENT_SECRET) return null;

  const refreshed = await xsDevOauth_tokenRequest({
    grant_type: "refresh_token",
    refresh_token: rec.refresh_token,
    client_id: xsDevOauth_CLIENT_ID,
    client_secret: xsDevOauth_CLIENT_SECRET,
  });

  rec.access_token  = refreshed.access_token  || rec.access_token;
  rec.refresh_token = refreshed.refresh_token || rec.refresh_token;
  rec.expires_in    = refreshed.expires_in;
  rec.expires_at    = xsDevOauth_nowSec() + (refreshed.expires_in || 0);
  rec.refreshed_at  = new Date().toISOString();

  devices[deviceId] = rec;
  xsDevOauth_writeJson(xsDevOauth_DEVICES_FILE, devices);
  return rec.access_token || null;
}

// --- Routes (nouveau namespace) ---
app.get("/auth/sorare-device/login", (req, res) => {
  const deviceId = String(req.query.deviceId || "").trim();
  if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

  if (!xsDevOauth_CLIENT_ID) {
    return res.status(500).json({ error: "Missing env client id (SORARE_OAUTH_CLIENT_ID)" });
  }

  const state = Math.random().toString(36).slice(2) + "." + Date.now();
  const states = xsDevOauth_readJson(xsDevOauth_STATES_FILE, {});
  states[state] = { deviceId: deviceId, created_at: new Date().toISOString() };
  xsDevOauth_writeJson(xsDevOauth_STATES_FILE, states);

  const u = new URL("https://sorare.com/oauth/authorize");
  u.searchParams.set("client_id", xsDevOauth_CLIENT_ID);
  u.searchParams.set("redirect_uri", xsDevOauth_REDIRECT);
  u.searchParams.set("response_type", "code");
  u.searchParams.set("scope", "public");
  u.searchParams.set("state", state);

  res.redirect(u.toString());
});

app.get("/auth/sorare-device/callback", async (req, res) => {
  try {
    const code = String(req.query.code || "");
    const state = String(req.query.state || "");
    if (!code) return res.status(400).send("Missing code");
    if (!state) return res.status(400).send("Missing state");

    const states = xsDevOauth_readJson(xsDevOauth_STATES_FILE, {});
    const st = states[state];
    if (!st || !st.deviceId) return res.status(400).send("Invalid state");
    const deviceId = st.deviceId;

    if (!xsDevOauth_CLIENT_ID || !xsDevOauth_CLIENT_SECRET) {
      return res.status(500).send("Missing env client id/secret (SORARE_OAUTH_CLIENT_ID/_SECRET)");
    }

    const token = await xsDevOauth_tokenRequest({
      grant_type: "authorization_code",
      code: code,
      client_id: xsDevOauth_CLIENT_ID,
      client_secret: xsDevOauth_CLIENT_SECRET,
      redirect_uri: xsDevOauth_REDIRECT,
    });

    const accessToken = token.access_token;
    if (!accessToken) return res.status(500).send("No access_token received");

    const me = await xsDevOauth_graphql(accessToken, "query { currentUser { slug nickname } }", {});
    const cu = me && me.data && me.data.currentUser ? me.data.currentUser : null;
    if (!cu || !cu.slug) return res.status(500).send("Unable to read currentUser");

    const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
    devices[deviceId] = {
      userSlug: cu.slug,
      nickname: cu.nickname || null,
      access_token: token.access_token,
      refresh_token: token.refresh_token,
      expires_in: token.expires_in,
      expires_at: xsDevOauth_nowSec() + (token.expires_in || 0),
      linked_at: new Date().toISOString(),
    };
    xsDevOauth_writeJson(xsDevOauth_DEVICES_FILE, devices);

    // cleanup state
    delete states[state];
    xsDevOauth_writeJson(xsDevOauth_STATES_FILE, states);

    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.end("<h2>✅ Connexion Sorare (device) OK</h2><p>Retourne dans l’app. Tu peux fermer cet onglet.</p>");
  } catch (e) {
    res.status(500).send(String(e && e.message ? e.message : e));
  }
});

app.get("/auth/device-status", (req, res) => {
  const deviceId = String(req.query.deviceId || "").trim();
  if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

  const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
  const rec = devices[deviceId];
  if (!rec) return res.json({ linked: false });

  res.json({ linked: true, userSlug: rec.userSlug, nickname: rec.nickname || null });
});

app.get("/auth/sorare-device/me", async (req, res) => {
  try {
    const deviceId = String(req.query.deviceId || "").trim();
    const tok = await xsDevOauth_getTokenForDevice(deviceId);
    if (!tok) return res.status(401).json({ error: "Not linked. Use /auth/sorare-device/login?deviceId=..." });

    const out = await xsDevOauth_graphql(tok, "query { currentUser { slug nickname } }", {});
    res.json(out);
  } catch (e) {
    res.status(500).json({ error: String(e && e.message ? e.message : e) });
  }
});

// ===== /XS_DEVICE_OAUTH_V1 =====

  // ===== XS_ME_V1 =====
  // Endpoint privé: identité utilisateur via token OAuth stocké (deviceId -> access_token)
  // ⚠️ Ne renvoie JAMAIS le token au client.

  function xsMe_getDevice(deviceId) {
    try {
      const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
      return devices && devices[deviceId] ? devices[deviceId] : null;
    } catch (e) {
      return null;
    }
  }

  function xsMe_getAccessToken(deviceId) {
    const d = xsMe_getDevice(deviceId);
    if (!d) return null;
    return d.access_token || null;
  }

  app.get("/me", async (req, res) => {
    try {
      const deviceId = String(req.query.deviceId || "").trim();
      if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

      const tok = xsMe_getAccessToken(deviceId);
      if (!tok) return res.status(401).json({ error: "Not linked. Use /auth/sorare-device/login?deviceId=..." });

      const q = "query { currentUser { slug nickname } }";
      const me = await xsDevOauth_graphql(tok, q, {});

      const cu = me && me.data && me.data.currentUser ? me.data.currentUser : null;
      if (!cu || !cu.slug) return res.status(502).json({ error: "Unable to read currentUser", raw: me });

      res.json({ ok: true, userSlug: cu.slug, nickname: cu.nickname || null });
    } catch (e) {
      res.status(500).json({ error: String(e && e.message ? e.message : e) });
    }
  });

  // ===== /XS_ME_V1 =====

  // ===== XS_DEVICE_UNLINK_V1 =====
  // Dé-lie un deviceId (supprime son token stocké). Utile pour "logout" réel.
  // ⚠️ Ne renvoie jamais de token.
  app.get("/auth/device-unlink", async (req, res) => {
    try {
      const deviceId = String(req.query.deviceId || "").trim();
      if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

      const devices = xsDevOauth_readJson(xsDevOauth_DEVICES_FILE, {});
      if (devices && devices[deviceId]) {
        delete devices[deviceId];
        xsDevOauth_writeJson(xsDevOauth_DEVICES_FILE, devices);
      }

      // on supprime aussi un state éventuel (optionnel)
      try {
        const states = xsDevOauth_readJson(xsDevOauth_STATES_FILE, {});
        for (const k of Object.keys(states || {})) {
          if (states[k] && states[k].deviceId === deviceId) delete states[k];
        }
        xsDevOauth_writeJson(xsDevOauth_STATES_FILE, states);
      } catch {}

      return res.json({ ok: true, unlinked: true, deviceId });
    } catch (e) {
      return res.status(500).json({ error: String(e && e.message ? e.message : e) });
    }
  });
  // ===== /XS_DEVICE_UNLINK_V1 =====

  // ===== XS_MARKET_AUTH_RAW_V1 =====
  // Debug: prouve qu'on peut appeler une query "marché" avec Authorization: Bearer (token user via deviceId).
  // Ne casse rien : endpoint nouveau, et on renvoie le brut pour inspecter la shape.

  app.get("/market/auth/raw", async (req, res) => {
    try {
      const deviceId = String(req.query.deviceId || "").trim();
      if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

      // xsMe_getAccessToken vient du patch XS_ME_V1
      const tok = (typeof xsMe_getAccessToken === "function") ? xsMe_getAccessToken(deviceId) : null;
      if (!tok) return res.status(401).json({ error: "Not linked. Use /auth/sorare-device/login?deviceId=..." });

      // Params simples
      const first = Math.max(1, Math.min(50, Number(req.query.first || 10)));
      const after = String(req.query.after || "") || null;

      // ⚠️ Query volontairement MINIMALE pour éviter les erreurs de schéma.
      // On teste juste "liveSingleSaleOffers" + prix en EUR cents.
      // Si Sorare renvoie une erreur de schéma, on l'affiche en clair (sans casser le serveur).
      const query = `
        query MarketAuthRaw($first: Int!, $after: String) {
          tokens {
            liveSingleSaleOffers(first: $first, after: $after) {
              nodes {
                id
                price { amounts { eurCents } }
              }
              pageInfo { endCursor hasNextPage }
            }
          }
        }
      `;

      const vars = { first, after };

      const r = await xsDevOauth_graphql(tok, query, vars);

      // On renvoie brut + un petit résumé
      const offers = r?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
      res.json({
        ok: true,
        deviceId,
        count: Array.isArray(offers) ? offers.length : 0,
        sample: Array.isArray(offers) && offers[0] ? offers[0] : null,
        raw: r
      });
    } catch (e) {
      res.status(500).json({ error: String(e && e.message ? e.message : e) });
    }
  });

  // ===== /XS_MARKET_AUTH_RAW_V1 =====

  // ===== XS_MARKET_AUTH_INSPECT_V1 =====
  // Découverte safe du schéma: on trouve le bon champ de prix sur TokenOffer en testant plusieurs candidats.

  app.get("/market/auth/inspect", async (req, res) => {
    try {
      const deviceId = String(req.query.deviceId || "").trim();
      if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

      const tok = (typeof xsMe_getAccessToken === "function") ? xsMe_getAccessToken(deviceId) : null;
      if (!tok) return res.status(401).json({ error: "Not linked. Use /auth/sorare-device/login?deviceId=..." });

      const first = Math.max(1, Math.min(20, Number(req.query.first || 5)));
      const after = String(req.query.after || "") || null;

      // 1) Query minimale: id + __typename (doit passer)
      const q0 = `
        query Q0($first: Int!, $after: String) {
          tokens {
            liveSingleSaleOffers(first: $first, after: $after) {
              nodes { id __typename }
              pageInfo { endCursor hasNextPage }
            }
          }
        }
      `;
      const vars = { first, after };
      const base = await xsDevOauth_graphql(tok, q0, vars);

      const nodes0 = base?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
      const typename = nodes0 && nodes0[0] ? nodes0[0].__typename : null;

      // 2) On tente des candidats de prix (un par un) pour éviter de casser si un champ n'existe pas
      const candidates = [
        "buyNowPrice",
        "startPrice",
        "startingPrice",
        "currentPrice",
        "priceInFiat",
        "fiatPrice",
        "price",          // on sait déjà que NON sur TokenOffer, mais on le garde pour debug
        "amount",
      ];

      let winner = null;
      let winnerRaw = null;
      let lastErr = null;

      for (const f of candidates) {
        const qTry = `
          query QTry($first: Int!, $after: String) {
            tokens {
              liveSingleSaleOffers(first: $first, after: $after) {
                nodes {
                  id
                  __typename
                  ${f} { amounts { eurCents } }
                }
                pageInfo { endCursor hasNextPage }
              }
            }
          }
        `;
        try {
          const r = await xsDevOauth_graphql(tok, qTry, vars);
          const n = r?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
          if (Array.isArray(n) && n.length) {
            // Si le champ existe, il sera présent (ou null) — mais la query passe = victoire
            winner = f;
            winnerRaw = r;
            break;
          }
        } catch (e) {
          lastErr = String(e && e.message ? e.message : e);
          continue;
        }
      }

      res.json({
        ok: true,
        deviceId,
        typename,
        count: Array.isArray(nodes0) ? nodes0.length : 0,
        baseSample: Array.isArray(nodes0) && nodes0[0] ? nodes0[0] : null,
        priceField: winner,
        priceSample: winnerRaw?.data?.tokens?.liveSingleSaleOffers?.nodes?.[0] || null,
        lastError: winner ? null : lastErr,
      });
    } catch (e) {
      res.status(500).json({ error: String(e && e.message ? e.message : e) });
    }
  });

  // ===== /XS_MARKET_AUTH_INSPECT_V1 =====

  // ===== XS_MARKET_FIELDHUNT_V1 =====
  // Scan de champs potentiels sur TokenOffer, sans introspection.
  // - Si champ scalaire: on le lit direct.
  // - Si champ objet: on lit { __typename }.
  // On renvoie un tableau avec succès/erreur par champ.

  app.get("/market/auth/fieldhunt", async (req, res) => {
    try {
      const deviceId = String(req.query.deviceId || "").trim();
      if (!deviceId) return res.status(400).json({ error: "Missing deviceId" });

      const tok = (typeof xsMe_getAccessToken === "function") ? xsMe_getAccessToken(deviceId) : null;
      if (!tok) return res.status(401).json({ error: "Not linked. Use /auth/sorare-device/login?deviceId=..." });

      const first = Math.max(1, Math.min(10, Number(req.query.first || 3)));
      const after = String(req.query.after || "") || null;
      const vars = { first, after };

      // 0) base: on récupère un node id pour tester
      const q0 = `
        query Q0($first: Int!, $after: String) {
          tokens {
            liveSingleSaleOffers(first: $first, after: $after) {
              nodes { id __typename }
              pageInfo { endCursor hasNextPage }
            }
          }
        }
      `;
      const base = await xsDevOauth_graphql(tok, q0, vars);
      const nodes0 = base?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
      const sample0 = Array.isArray(nodes0) && nodes0[0] ? nodes0[0] : null;
      if (!sample0?.id) return res.json({ ok: true, deviceId, note: "No offers to inspect", base });

      const candidates = [
        // très communs
        "buyNowPrice","startPrice","startingPrice","currentPrice","price","amount",
        // fiats
        "fiatPrice","priceInFiat","fiatAmount","eurAmount","usdAmount",
        // crypto / wei / eth
        "weiAmount","priceWei","ethAmount","cryptoAmount",
        // enchères / offres
        "currentBid","bestBid","bidAmount","reservePrice","endPrice",
        // autres noms possibles
        "dealPrice","dealAmount","salePrice","finalPrice","acceptedPrice",
        "priceInEur","eurPrice","minPrice","maxPrice"
      ];

      async function tryScalar(fieldName) {
        const q = `
          query QScalar($first: Int!, $after: String) {
            tokens {
              liveSingleSaleOffers(first: $first, after: $after) {
                nodes { id __typename ${fieldName} }
                pageInfo { endCursor hasNextPage }
              }
            }
          }
        `;
        return await xsDevOauth_graphql(tok, q, vars);
      }

      async function tryObjectTypename(fieldName) {
        const q = `
          query QObject($first: Int!, $after: String) {
            tokens {
              liveSingleSaleOffers(first: $first, after: $after) {
                nodes { id __typename ${fieldName} { __typename } }
                pageInfo { endCursor hasNextPage }
              }
            }
          }
        `;
        return await xsDevOauth_graphql(tok, q, vars);
      }

      const results = [];

      for (const f of candidates) {
        // 1) scalar attempt
        try {
          const r1 = await tryScalar(f);
          const n1 = r1?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
          const s1 = Array.isArray(n1) && n1[0] ? n1[0] : null;
          results.push({
            field: f,
            ok: true,
            kind: "scalar",
            sample: s1 && Object.prototype.hasOwnProperty.call(s1, f) ? s1[f] : null
          });
          continue;
        } catch (e1) {
          const msg1 = String(e1 && e1.message ? e1.message : e1);

          // 2) si l'erreur ressemble à "must have a selection of subfields", c'est probablement un objet
          // (sinon on tente quand même QObject pour être sûr)
          try {
            const r2 = await tryObjectTypename(f);
            const n2 = r2?.data?.tokens?.liveSingleSaleOffers?.nodes || [];
            const s2 = Array.isArray(n2) && n2[0] ? n2[0] : null;
            const obj = s2 ? s2[f] : null;

            results.push({
              field: f,
              ok: true,
              kind: "object",
              objectType: obj && obj.__typename ? obj.__typename : null,
              sample: obj || null
            });
          } catch (e2) {
            const msg2 = String(e2 && e2.message ? e2.message : e2);
            results.push({
              field: f,
              ok: false,
              errScalar: msg1,
              errObject: msg2
            });
          }
        }
      }

      res.json({
        ok: true,
        deviceId,
        baseSample: sample0,
        results
      });
    } catch (e) {
      res.status(500).json({ error: String(e && e.message ? e.message : e) });
    }
  });

  // ===== /XS_MARKET_FIELDHUNT_V1 =====























