/**
 * Companion Sorare — backend propre
 * - /health
 * - /public-user-cards-page?identifier=darkflow&first=20&after=...&enrich=1
 * - /public-player?slug=...
 * - /scout/cards?first=20&eurOnly=1&q=mbappe&rarities=limited,rare&maxEur=50&sort=eur_asc
 * - /scout/watchlist (GET/POST/DELETE)
 * - /scout/alerts (GET/POST/DELETE)
 *
 * Node >= 18 (fetch dispo). Recommandé: Node 20.
 */

const express = require("express");
const cors = require("cors");

const app = express();
app.use(cors());
app.use(express.json());

// ----------------------------
// Config
// ----------------------------
const PORT = Number(process.env.PORT || 3000);
const HOST = process.env.HOST || "0.0.0.0";

// IMPORTANT: endpoint GraphQL (on force federation)
const SORARE_GQL = "https://api.sorare.com/federation/graphql";

// ----------------------------
// Utils: Disk JSON
// ----------------------------
function dataFile(name) {
  const path = require("path");
  return path.join(__dirname, "data", name);
}

function readJson(file, fallback) {
  try {
    const fs = require("fs");
    if (!fs.existsSync(file)) return fallback;
    const raw = fs.readFileSync(file, "utf8");
    if (!raw) return fallback;
    return JSON.parse(raw);
  } catch {
    return fallback;
  }
}

function writeJson(file, obj) {
  try {
    const fs = require("fs");
    const path = require("path");
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(file, JSON.stringify(obj, null, 2), "utf8");
  } catch {}
}

// ----------------------------
// Disk cache (scout)
// ----------------------------
function scoutCacheFile() {
  return dataFile("scout_cache.json");
}

function scoutCacheRead() {
  const j = readJson(scoutCacheFile(), {});
  // support old formats too:
  // { last: {key, items, ts}, byKey: {key: payload} }
  // OR { key, items, cachedAt } (ancien)
  if (j && typeof j === "object") {
    if (j.byKey || j.last) {
      return { last: j.last || null, byKey: j.byKey || {} };
    }
    if (j.key && Array.isArray(j.items)) {
      const payload = { key: j.key, items: j.items, ts: Date.now() };
      return { last: payload, byKey: { [j.key]: payload } };
    }
  }
  return { last: null, byKey: {} };
}

function scoutCacheWrite(c) {
  writeJson(scoutCacheFile(), c);
}

function scoutCacheGet(key) {
  const c = scoutCacheRead();
  if (c.byKey && c.byKey[key]) return c.byKey[key];
  return c.last || null;
}

function scoutCacheSet(key, payload) {
  const c = scoutCacheRead();
  c.byKey = c.byKey || {};
  c.byKey[key] = payload;
  c.last = payload;
  scoutCacheWrite(c);
}

// ----------------------------
// Sorare GraphQL helper
// ----------------------------
async function sorareGraphQL(query, variables) {
  const res = await fetch(SORARE_GQL, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ query, variables: variables || {} }),
  });

  // ex: 429, 502...
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    const err = new Error(`Sorare HTTP ${res.status}`);
    err.status = res.status;
    err.body = txt;
    throw err;
  }

  const json = await res.json();
  if (json.errors && json.errors.length) {
    const err = new Error(json.errors[0]?.message || "Sorare GraphQL error");
    err.graphQLErrors = json.errors;
    err.data = json.data;
    throw err;
  }
  return json.data;
}

// ----------------------------
// Identifier -> slug (user)
// ----------------------------
function resolveUserSlug(identifier) {
  const s = String(identifier || "").trim();
  if (!s) return "";

  // URL sorare club
  // ex: https://sorare.com/fr/football/my-club/darkflow
  // ex: https://sorare.com/fr/football/clubs/darkflow
  const m1 = s.match(/sorare\.com\/[^\/]+\/football\/my-club\/([^\/\?#]+)/i);
  if (m1) return m1[1];
  const m2 = s.match(/sorare\.com\/[^\/]+\/football\/clubs\/([^\/\?#]+)/i);
  if (m2) return m2[1];

  // sinon on suppose slug direct
  return s.replace(/^@/, "");
}

// ----------------------------
// anyCards enrichment (robuste avec fallbacks)
// ----------------------------
async function fetchAnyCards(slugs) {
  const uniq = Array.from(new Set((slugs || []).filter(Boolean)));
  if (!uniq.length) return [];

  const queries = [
    // "riche" (peut échouer si certains champs n'existent pas)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          serialNumber
          anyPositions
          pictureUrl
          anyTeam { name slug }
          anyPlayer { displayName slug }
        }
      }
    `,
    // fallback 1 (retire slug player/team si ça casse)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          serialNumber
          anyPositions
          pictureUrl
          anyTeam { name }
          anyPlayer { displayName }
        }
      }
    `,
    // fallback 2 (minimal)
    `
      query AnyCards($slugs:[String!]) {
        anyCards(slugs:$slugs) {
          slug
          rarityTyped
          seasonYear
          anyPositions
        }
      }
    `,
  ];

  let lastErr = null;
  for (const q of queries) {
    try {
      const data = await sorareGraphQL(q, { slugs: uniq });
      return (data && data.anyCards) ? data.anyCards : [];
    } catch (e) {
      lastErr = e;
    }
  }
  throw lastErr || new Error("anyCards failed");
}

// ----------------------------
// Live single sale offers (public) + EUR best-effort
// ----------------------------
async function fetchLiveSingleSaleOffers(lastN) {
  const N = Math.max(1, Math.min(Number(lastN || 50), 200));

  // Try #1: eurCents (si le champ existe)
  const qEur = `
    query Live($last:Int!) {
      tokens {
        liveSingleSaleOffers(last:$last) {
          nodes {
            id
            senderSide {
              anyCards { slug }
              amounts { eurCents }
            }
          }
        }
      }
    }
  `;

  try {
    const data = await sorareGraphQL(qEur, { last: N });
    const nodes = data?.tokens?.liveSingleSaleOffers?.nodes || [];
    return { nodes, eurMode: "eurCents" };
  } catch (e) {
    // Try #2: wei (fallback)
    const qWei = `
      query Live($last:Int!) {
        tokens {
          liveSingleSaleOffers(last:$last) {
            nodes {
              id
              senderSide {
                anyCards { slug }
                amounts { wei }
              }
            }
          }
        }
      }
    `;
    const data2 = await sorareGraphQL(qWei, { last: N });
    const nodes2 = data2?.tokens?.liveSingleSaleOffers?.nodes || [];
    return { nodes: nodes2, eurMode: "weiOnly" };
  }
}

// ----------------------------
// Routes
// ----------------------------
app.get("/health", (req, res) => res.json({ ok: true }));

// Public user cards (paged)
app.get("/public-user-cards-page", async (req, res) => {
  try {
    const identifier = String(req.query.identifier || "").trim();
    const first = Math.max(1, Math.min(Number(req.query.first || 20), 10));
    const after = req.query.after ? String(req.query.after) : null;
    const enrich = String(req.query.enrich || "0") === "1";

    const slug = resolveUserSlug(identifier);
    if (!slug) return res.status(400).json({ error: "identifier missing" });

    // Query minimal (robuste)
    const q1 = `
      query UserCards($slug:String!, $first:Int!, $after:String) {
        user(slug:$slug) {
          slug
          nickname
          cards(first:$first, after:$after) {
            nodes { slug pictureUrl }
            pageInfo { endCursor hasNextPage }
          }
        }
      }
    `;

    let userData;
    try {
      userData = await sorareGraphQL(q1, { slug, first, after });
    } catch (e) {
      // fallback sans pictureUrl si ça casse
      const q2 = `
        query UserCards($slug:String!, $first:Int!, $after:String) {
          user(slug:$slug) {
            slug
            nickname
            cards(first:$first, after:$after) {
              nodes { slug }
              pageInfo { endCursor hasNextPage }
            }
          }
        }
      `;
      userData = await sorareGraphQL(q2, { slug, first, after });
    }

    const u = userData?.user;
    if (!u) return res.status(404).json({ error: "user not found or not public" });

    let cards = (u.cards?.nodes || []).map(c => ({
      slug: c.slug,
      pictureUrl: c.pictureUrl || null,
    }));

    // Enrich via anyCards(slugs)
    if (enrich && cards.length) {
      const slugs = cards.map(c => c.slug).filter(Boolean);
      const enriched = await fetchAnyCards(slugs);
      const map = new Map(enriched.map(x => [x.slug, x]));

      cards = cards.map(c => {
        const e = map.get(c.slug);
        if (!e) return c;
        return {
          ...c,
          pictureUrl: c.pictureUrl || e.pictureUrl || null,
          rarity: e.rarityTyped || null,
          seasonYear: e.seasonYear || null,
          serialNumber: (typeof e.serialNumber === "number") ? e.serialNumber : null,
          position: Array.isArray(e.anyPositions) ? (e.anyPositions[0] || null) : null,
          positions: Array.isArray(e.anyPositions) ? e.anyPositions : [],
          team: e.anyTeam?.name || null,
          teamSlug: e.anyTeam?.slug || null,
          playerName: e.anyPlayer?.displayName || null,
          playerSlug: e.anyPlayer?.slug || null,
        };
      });
    }

    res.json({
      slug: u.slug,
      nickname: u.nickname || null,
      cards,
      pageInfo: u.cards?.pageInfo || { endCursor: null, hasNextPage: false },
    });
  } catch (e) {
    res.status(500).json({
      error: String(e.message || e),
      status: e.status || null,
      graphQLErrors: e.graphQLErrors || null,
    });
  }
});

// Public player info (best-effort, plusieurs shapes)
app.get("/public-player", async (req, res) => {
  const slug = String(req.query.slug || "").trim();
  if (!slug) return res.status(400).json({ error: "slug missing" });

  const tries = [
    // shape 1
    `
      query P($slug:String!) {
        football {
          player(slug:$slug) {
            slug
            displayName
            anyPositions
            activeClub { name slug }
          }
        }
      }
    `,
    // shape 2
    `
      query P($slug:String!) {
        footballPlayer(slug:$slug) {
          slug
          displayName
          anyPositions
          activeClub { name slug }
        }
      }
    `,
    // shape 3
    `
      query P($slug:String!) {
        player(slug:$slug) {
          ... on FootballPlayer {
            slug
            displayName
            anyPositions
            activeClub { name slug }
          }
        }
      }
    `,
  ];

  let lastErr = null;
  for (const q of tries) {
    try {
      const data = await sorareGraphQL(q, { slug });
      const p =
        data?.football?.player ||
        data?.footballPlayer ||
        data?.player ||
        null;

      if (!p) continue;

      return res.json({
        slug: p.slug || slug,
        displayName: p.displayName || null,
        positions: Array.isArray(p.anyPositions) ? p.anyPositions : [],
        position: Array.isArray(p.anyPositions) ? (p.anyPositions[0] || null) : null,
        activeClub: p.activeClub ? { name: p.activeClub.name || null, slug: p.activeClub.slug || null } : null,
      });
    } catch (e) {
      lastErr = e;
    }
  }

  return res.status(500).json({
    error: "public-player query failed (schema mismatch).",
    details: String(lastErr?.message || lastErr || ""),
    graphQLErrors: lastErr?.graphQLErrors || null,
  });
});

// Scout — cards (public market snapshot + cache)
app.get("/scout/cards", async (req, res) => {
  const first = Math.max(1, Math.min(Number(req.query.first || 20), 10));
  const eurOnly = String(req.query.eurOnly || "0") === "1";
  const maxEur = req.query.maxEur ? Number(req.query.maxEur) : null;
  const qRaw = String(req.query.q || "").trim().toLowerCase();
  const raritiesRaw = String(req.query.rarities || "").trim().toLowerCase(); // "limited,rare"
  const sort = String(req.query.sort || "").trim().toLowerCase(); // eur_asc|eur_desc|newest

  const rarities = raritiesRaw
    ? raritiesRaw.split(",").map(s => s.trim()).filter(Boolean)
    : [];

  const cacheKey = ["scout", qRaw, rarities.join(","), eurOnly ? "eur" : "any", (Number.isFinite(maxEur) ? maxEur : ""), sort].join("|");
  const cached = scoutCacheGet(cacheKey);
  let fromCache = false;
  let cacheExact = false;

  try {
    // On tire plus large, puis on filtre localement (public API limitée)
    const lastN = 10; // public-safe: évite "complexity > 500" sans APIKEY
    const { nodes, eurMode } = await fetchLiveSingleSaleOffers(lastN);

    // Flatten offers -> card slugs
    const offers = [];
    const slugs = [];
    for (const o of (nodes || [])) {
      const c = o?.senderSide?.anyCards?.[0];
      if (!c?.slug) continue;

      let eur = null;
      const amt = o?.senderSide?.amounts || null;
      if (amt) {
        if (typeof amt.eurCents === "number") eur = amt.eurCents / 100;
      }

      offers.push({
        offerId: o.id,
        slug: c.slug,
        pictureUrl: c.pictureUrl || null,
        eur,
        eurMode,
      });
      slugs.push(c.slug);
    }

    // Enrich cards (player/team/positions/rarity/seasonYear)
    let enriched = [];
    try {
      enriched = await fetchAnyCards(slugs);
    } catch {
      enriched = [];
    }
    const map = new Map(enriched.map(x => [x.slug, x]));

    let items = offers.map(o => {
      const e = map.get(o.slug);
      const rarity = e?.rarityTyped || null;

      return {
        offerId: o.offerId,
        slug: o.slug,
        pictureUrl: o.pictureUrl || e?.pictureUrl || null,
        rarity,
        seasonYear: e?.seasonYear || null,
        serialNumber: (typeof e?.serialNumber === "number") ? e.serialNumber : null,
        positions: Array.isArray(e?.anyPositions) ? e.anyPositions : [],
        position: Array.isArray(e?.anyPositions) ? (e.anyPositions[0] || null) : null,
        team: e?.anyTeam?.name || null,
        teamSlug: e?.anyTeam?.slug || null,
        playerName: e?.anyPlayer?.displayName || null,
        playerSlug: e?.anyPlayer?.slug || null,
        eur: o.eur,
      };
    });

    // Filters
    if (rarities.length) {
      items = items.filter(x => x.rarity && rarities.includes(String(x.rarity).toLowerCase()));
    }
    if (qRaw) {
      items = items.filter(x => {
        const pn = String(x.playerName || "").toLowerCase();
        const ps = String(x.playerSlug || "").toLowerCase();
        const ts = String(x.team || "").toLowerCase();
        return pn.includes(qRaw) || ps.includes(qRaw) || ts.includes(qRaw);
      });
    }
    if (eurOnly) {
      items = items.filter(x => typeof x.eur === "number" && Number.isFinite(x.eur));
    }
    if (Number.isFinite(maxEur)) {
      items = items.filter(x => (typeof x.eur === "number" && x.eur <= maxEur));
    }

    // Sort
    if (sort === "eur_asc") {
      items.sort((a,b) => (a.eur ?? Infinity) - (b.eur ?? Infinity));
    } else if (sort === "eur_desc") {
      items.sort((a,b) => (b.eur ?? -Infinity) - (a.eur ?? -Infinity));
    } // else "newest": keep order

    // Trim to first
    items = items.slice(0, first);

    // Cache fallback if empty
    if ((!items || items.length === 0) && cached && Array.isArray(cached.items) && cached.items.length) {
      items = cached.items;
      fromCache = true;
      cacheExact = !!(cached.key && cached.key === cacheKey);
    }

    // Save cache if non-empty and not from cache
    if (!fromCache && Array.isArray(items) && items.length) {
      scoutCacheSet(cacheKey, { key: cacheKey, items, ts: Date.now() });
    }

    res.json({
      key: cacheKey,
      fromCache,
      cacheExact,
      count: items.length,
      items,
      note: "V1: liveSingleSaleOffers (public). Limite PUBLIC: first cap à 10 + last=10 pour rester sous complexity=500. Attention: rate-limit possible; filtres appliqués localement.",
    });
  } catch (e) {
    // On tente cache en dernier recours
    if (cached && Array.isArray(cached.items) && cached.items.length) {
      fromCache = true;
      cacheExact = !!(cached.key && cached.key === cacheKey);
      return res.json({
        key: cacheKey,
        fromCache,
        cacheExact,
        count: cached.items.length,
        items: cached.items,
        note: "Fallback cache (erreur API publique).",
        apiError: String(e.message || e),
        apiStatus: e.status || null,
      });
    }

    res.status(500).json({
      error: String(e.message || e),
      status: e.status || null,
      graphQLErrors: e.graphQLErrors || null,
    });
  }
});

// ----------------------------
// Watchlist / Alerts (simple JSON CRUD)
// ----------------------------
const WATCHLIST_FILE = dataFile("scout_watchlist.json");
const ALERTS_FILE = dataFile("scout_alerts.json");

app.get("/scout/watchlist", (req, res) => {
  const list = readJson(WATCHLIST_FILE, []);
  res.json({ items: Array.isArray(list) ? list : [] });
});

app.post("/scout/watchlist", (req, res) => {
  const list = readJson(WATCHLIST_FILE, []);
  const item = req.body || {};
  const id = item.id || ("w_" + Date.now() + "_" + Math.random().toString(16).slice(2));
  const next = Array.isArray(list) ? list : [];
  next.push({ ...item, id });
  writeJson(WATCHLIST_FILE, next);
  res.json({ ok: true, id });
});

app.delete("/scout/watchlist/:id", (req, res) => {
  const id = String(req.params.id || "");
  const list = readJson(WATCHLIST_FILE, []);
  const next = (Array.isArray(list) ? list : []).filter(x => String(x.id) !== id);
  writeJson(WATCHLIST_FILE, next);
  res.json({ ok: true });
});

app.get("/scout/alerts", (req, res) => {
  const list = readJson(ALERTS_FILE, []);
  res.json({ items: Array.isArray(list) ? list : [] });
});

app.post("/scout/alerts", (req, res) => {
  const list = readJson(ALERTS_FILE, []);
  const item = req.body || {};
  const id = item.id || ("a_" + Date.now() + "_" + Math.random().toString(16).slice(2));
  const next = Array.isArray(list) ? list : [];
  next.push({ ...item, id });
  writeJson(ALERTS_FILE, next);
  res.json({ ok: true, id });
});

app.delete("/scout/alerts/:id", (req, res) => {
  const id = String(req.params.id || "");
  const list = readJson(ALERTS_FILE, []);
  const next = (Array.isArray(list) ? list : []).filter(x => String(x.id) !== id);
  writeJson(ALERTS_FILE, next);
  res.json({ ok: true });
});

// ----------------------------
app.listen(PORT, HOST, () => {
  console.log(`[OK] Companion backend on http://${HOST}:${PORT}`);
  console.log(`[OK] GraphQL -> ${SORARE_GQL}`);
});

